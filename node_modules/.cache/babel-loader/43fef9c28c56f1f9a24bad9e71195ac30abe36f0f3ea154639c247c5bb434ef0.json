{"ast":null,"code":"let NUMBER_OF_PEGS=20;const PEG_RADIUS=10;/**\n * This method will generate level 1\n */const LevelOne=()=>{let redPegCount=0;let bluePegCount=0;const rows=5;const cols=7;const spacing=50;const startX=40;const startY=170;let pegs=[];for(let row=0;row<rows;row++){for(let col=0;col<cols;col++){let pegType=\"blue\";// Ensure red pegs don't exceed blue pegs\nif(Math.random()<0.3&&redPegCount<bluePegCount/2){pegType=\"red\";redPegCount++;}bluePegCount++;// Increment blue peg count regardless\n// Shift half of the rows\nlet xOffset=0;if(row%2==0){xOffset=25;}pegs.push({x:startX+xOffset+col*spacing,y:startY+row*spacing,radius:typeof PEG_RADIUS!==\"undefined\"?PEG_RADIUS:10,// Default radius if undefined\nhit:false,type:pegType});}}return pegs;};/**\n * This method will generate level 2\n */const LevelTwo=()=>{let pegs=[];let redPegCount=0;let bluePegCount=0;// Define center of the X\nconst centerX=200;const centerY=300;// X dimensions\nconst armLength=150;const pegSpacing=25;// Generate diagonal lines\nfor(let i=-armLength;i<=armLength;i+=pegSpacing){let pegType=\"blue\";if(Math.random()<0.3&&redPegCount<bluePegCount){pegType=\"red\";redPegCount++;}else{bluePegCount++;}// First diagonal (TL to BR)\npegs.push({x:centerX+i,y:centerY+i,radius:PEG_RADIUS,hit:false,type:pegType});// Second diagonal (TR to BL)\npegs.push({x:centerX+i,y:centerY-i,radius:PEG_RADIUS,hit:false,type:pegType});}return pegs;};/**\n * This method will generate level 3\n * Smiley face :)\n */const LevelThree=()=>{let pegs=[];let redPegCount=0;let bluePegCount=0;// Define center of smiley face\nconst centerX=200;const centerY=300;// Eye positions\nconst eyeRadius=30;const leftEyeX=centerX-70;const rightEyeX=centerX+70;const eyeY=centerY-60;// Generate eye pegs\nconst eyePegCount=8;for(let i=0;i<eyePegCount;i++){let pegType=\"blue\";// Ensure red pegs don't exceed blue pegs\nif(Math.random()<0.3&&redPegCount<bluePegCount){pegType=\"red\";redPegCount++;}else{bluePegCount++;}// Push pegs\nlet angle=Math.PI*2*i/eyePegCount;pegs.push({x:leftEyeX+eyeRadius*Math.cos(angle),y:eyeY+eyeRadius*Math.sin(angle),radius:PEG_RADIUS,hit:false,type:pegType});pegs.push({x:rightEyeX+eyeRadius*Math.cos(angle),y:eyeY+eyeRadius*Math.sin(angle),radius:PEG_RADIUS,hit:false,type:pegType});}// Generate mouth pegs\nconst mouthRadius=90;const mouthY=centerY+30;const mouthPegCount=9;for(let i=0;i<mouthPegCount;i++){let pegType=\"blue\";// Ensure red pegs don't exceed blue pegs\nif(Math.random()<0.3&&redPegCount<bluePegCount){pegType=\"red\";redPegCount++;}else{bluePegCount++;}// Push pegs\nlet angle=Math.PI*(0.2+i/mouthPegCount*0.6);pegs.push({x:centerX+mouthRadius*Math.cos(angle),y:mouthY+mouthRadius*Math.sin(angle),radius:PEG_RADIUS,hit:false,type:pegType});}// Create outer face pegs\nconst faceRadius=150;const facePegCount=20;for(let i=0;i<facePegCount;i++){let pegType=\"blue\";// Ensure red pegs don't exceed blue pegs\nif(Math.random()<0.3&&redPegCount<bluePegCount){pegType=\"red\";redPegCount++;}else{bluePegCount++;}// Push pegs\nlet angle=Math.PI*2*i/facePegCount;pegs.push({x:centerX+faceRadius*Math.cos(angle),y:centerY+faceRadius*Math.sin(angle),radius:PEG_RADIUS,hit:false,type:pegType});}return pegs;};export{LevelOne,LevelTwo,LevelThree};","map":{"version":3,"names":["NUMBER_OF_PEGS","PEG_RADIUS","LevelOne","redPegCount","bluePegCount","rows","cols","spacing","startX","startY","pegs","row","col","pegType","Math","random","xOffset","push","x","y","radius","hit","type","LevelTwo","centerX","centerY","armLength","pegSpacing","i","LevelThree","eyeRadius","leftEyeX","rightEyeX","eyeY","eyePegCount","angle","PI","cos","sin","mouthRadius","mouthY","mouthPegCount","faceRadius","facePegCount"],"sources":["/Users/charliemclaughlin/Desktop/Programming/GitHub/piggle/src/Levels.js"],"sourcesContent":["let NUMBER_OF_PEGS = 20;\nconst PEG_RADIUS = 10;\n\n/**\n * This method will generate level 1\n */\nconst LevelOne = () => {\n    let redPegCount = 0;\n    let bluePegCount = 0;\n    \n    const rows = 5;\n    const cols = 7;\n    const spacing = 50;\n    const startX = 40;\n    const startY = 170;\n\n    let pegs = [];\n\n    for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n            let pegType = \"blue\";\n\n            // Ensure red pegs don't exceed blue pegs\n            if (Math.random() < 0.3 && redPegCount < (bluePegCount / 2)) {\n                pegType = \"red\";\n                redPegCount++;\n            }\n            bluePegCount++; // Increment blue peg count regardless\n            \n            // Shift half of the rows\n            let xOffset = 0; \n            if (row % 2 == 0){\n                xOffset = 25;\n            }\n\n            pegs.push({\n                x: startX + xOffset + (col * spacing),\n                y: startY + row * spacing,\n                radius: typeof PEG_RADIUS !== \"undefined\" ? PEG_RADIUS : 10, // Default radius if undefined\n                hit: false,\n                type: pegType\n            });\n        }\n    }\n\n    return pegs;\n};\n\n\n/**\n * This method will generate level 2\n */\nconst LevelTwo = () => {\n    let pegs = [];\n    let redPegCount = 0;\n    let bluePegCount = 0;\n\n    // Define center of the X\n    const centerX = 200;\n    const centerY = 300;\n    \n    // X dimensions\n    const armLength = 150;\n    const pegSpacing = 25;\n\n    // Generate diagonal lines\n    for (let i = -armLength; i <= armLength; i += pegSpacing) {\n        let pegType = \"blue\";\n        if (Math.random() < 0.3 && redPegCount < bluePegCount) {\n            pegType = \"red\";\n            redPegCount++;\n        } else {\n            bluePegCount++;\n        }\n        \n        // First diagonal (TL to BR)\n        pegs.push({ x: centerX + i, y: centerY + i, radius: PEG_RADIUS, hit: false, type: pegType });\n\n        // Second diagonal (TR to BL)\n        pegs.push({ x: centerX + i, y: centerY - i, radius: PEG_RADIUS, hit: false, type: pegType });\n    }\n\n    return pegs;\n};\n\n\n/**\n * This method will generate level 3\n * Smiley face :)\n */\nconst LevelThree = () => {\n    let pegs = [];\n    let redPegCount = 0;\n    let bluePegCount = 0;\n\n    // Define center of smiley face\n    const centerX = 200;\n    const centerY = 300;\n    \n    // Eye positions\n    const eyeRadius = 30;\n    const leftEyeX = centerX - 70;\n    const rightEyeX = centerX + 70;\n    const eyeY = centerY - 60;\n\n    // Generate eye pegs\n    const eyePegCount = 8;\n    for (let i = 0; i < eyePegCount; i++) {\n        let pegType = \"blue\";\n        // Ensure red pegs don't exceed blue pegs\n        if (Math.random() < 0.3 && redPegCount < bluePegCount) {\n            pegType = \"red\";\n            redPegCount++;\n        } else {\n            bluePegCount++;\n        }\n        // Push pegs\n        let angle = (Math.PI * 2 * i) / eyePegCount;\n        pegs.push({ x: leftEyeX + eyeRadius * Math.cos(angle), y: eyeY + eyeRadius * Math.sin(angle), radius: PEG_RADIUS, hit: false, type: pegType });\n        pegs.push({ x: rightEyeX + eyeRadius * Math.cos(angle), y: eyeY + eyeRadius * Math.sin(angle), radius: PEG_RADIUS, hit: false, type: pegType });\n    }\n\n    // Generate mouth pegs\n    const mouthRadius = 90;\n    const mouthY = centerY + 30;\n    const mouthPegCount = 9;\n    for (let i = 0; i < mouthPegCount; i++) {\n        let pegType = \"blue\";\n        // Ensure red pegs don't exceed blue pegs\n        if (Math.random() < 0.3 && redPegCount < bluePegCount) {\n            pegType = \"red\";\n            redPegCount++;\n        } else {\n            bluePegCount++;\n        }\n        // Push pegs\n        let angle = Math.PI * (0.2 + (i / mouthPegCount) * 0.6);\n        pegs.push({ x: centerX + mouthRadius * Math.cos(angle), y: mouthY + mouthRadius * Math.sin(angle), radius: PEG_RADIUS, hit: false, type: pegType });\n    }\n\n    // Create outer face pegs\n    const faceRadius = 150;\n    const facePegCount = 20; \n    for (let i = 0; i < facePegCount; i++) {\n        let pegType = \"blue\";\n        // Ensure red pegs don't exceed blue pegs\n        if (Math.random() < 0.3 && redPegCount < bluePegCount) {\n            pegType = \"red\";\n            redPegCount++;\n        } else {\n            bluePegCount++;\n        }\n        // Push pegs\n        let angle = (Math.PI * 2 * i) / facePegCount;\n        pegs.push({ x: centerX + faceRadius * Math.cos(angle), y: centerY + faceRadius * Math.sin(angle), radius: PEG_RADIUS, hit: false, type: pegType });\n    }\n\n    \n\n    return pegs;\n};\n\n\nexport { \n    LevelOne,\n    LevelTwo,\n    LevelThree\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"const NUMBER_OF_PEGS=20;const PEG_RADIUS=10;/**\n * This method will generate the pegs randomly\n * @returns The pegs generated in a random\n */const generatePegsRandomly=()=>Array.from({length:NUMBER_OF_PEGS},()=>({x:Math.random()*380+10,y:Math.random()*300+100,radius:PEG_RADIUS,hit:false}));/**\n * This method will generate the pegs in a square grid\n * @returns The pegs in a grid\n */const generatePegsGrid=()=>{// Rows and column number\nconst rows=5;const cols=5;// Peg spacing\nconst spacing=50;// Starting position for the top left peg\nconst startX=100;const startY=170;// Generate the pegs\nlet pegs=[];for(let row=0;row<rows;row++){for(let col=0;col<cols;col++){pegs.push({x:startX+col*spacing,y:startY+row*spacing,radius:PEG_RADIUS,hit:false});}}return pegs;};/**\n * Generate pegs in a circular shape\n * @returns The pegs in a circle\n */const generatePegsCircular=()=>{const centerX=200;const centerY=300;const radius=100;const angleIncrement=2*Math.PI/NUMBER_OF_PEGS;let pegs=[];for(let i=0;i<NUMBER_OF_PEGS;i++){const angle=angleIncrement*i;pegs.push({x:centerX+radius*Math.cos(angle),y:centerY+radius*Math.sin(angle),radius:PEG_RADIUS,hit:false});}return pegs;};/**\n * Generate pegs in a hexagonal formation\n * @returns Pegs generated in a hexagon\n */const generatePegsHexagonal=()=>{let pegs=[];const rows=5;const cols=5;const spacing=50;const startX=100;const startY=150;const verticalSpacing=spacing*Math.sqrt(3)/2;for(let row=0;row<rows;row++){const rowOffset=row%2===0?0:spacing/2;for(let col=0;col<cols;col++){pegs.push({x:startX+col*spacing+rowOffset,y:startY+row*verticalSpacing,radius:PEG_RADIUS,hit:false});}}return pegs;};/**\n * Generate the pegs in a triangular shape\n * @returns The pegs in a triangle shape\n */const generatePegsTriangular=()=>{// Array for pegs\nlet pegs=[];const numRows=5;// Start x for first row\nconst xPos=200;// Start y for first row\nconst yPos=220;// Peg spacing\nconst pegSpacing=40;for(let row=0;row<numRows;row++){// Center the row by adjusting the starting x position based on the row number\nconst startX=xPos-row*pegSpacing/2;for(let col=0;col<=row;col++){// Calculate the x and y positions for each peg in the current row\nconst x=startX+col*pegSpacing;const y=yPos+row*pegSpacing;pegs.push({x:x,y:y,radius:PEG_RADIUS,hit:false});}}return pegs;};export{generatePegsRandomly,generatePegsGrid,generatePegsCircular,generatePegsHexagonal,generatePegsTriangular};","map":{"version":3,"names":["NUMBER_OF_PEGS","PEG_RADIUS","generatePegsRandomly","Array","from","length","x","Math","random","y","radius","hit","generatePegsGrid","rows","cols","spacing","startX","startY","pegs","row","col","push","generatePegsCircular","centerX","centerY","angleIncrement","PI","i","angle","cos","sin","generatePegsHexagonal","verticalSpacing","sqrt","rowOffset","generatePegsTriangular","numRows","xPos","yPos","pegSpacing"],"sources":["/Users/charliemclaughlin/Desktop/Programming/GitHub/piggle/src/PegUtils.js"],"sourcesContent":["const NUMBER_OF_PEGS = 20;\nconst PEG_RADIUS = 10;\n/**\n * This method will generate the pegs randomly\n * @returns The pegs generated in a random\n */\nconst generatePegsRandomly = () => (\n    Array.from({ length: NUMBER_OF_PEGS }, () => ({\n        x: (Math.random() * 380) + 10,\n        y: (Math.random() * 300) + 100,\n        radius: PEG_RADIUS,\n        hit: false\n    }))\n);\n\n/**\n * This method will generate the pegs in a square grid\n * @returns The pegs in a grid\n */\nconst generatePegsGrid = () => {\n    // Rows and column number\n    const rows = 5;\n    const cols = 5;\n    // Peg spacing\n    const spacing = 50;\n    // Starting position for the top left peg\n    const startX = 100;\n    const startY = 170;\n\n    // Generate the pegs\n    let pegs = [];\n    for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n            pegs.push({\n                x: startX + col * spacing,\n                y: startY + row * spacing,\n                radius: PEG_RADIUS,\n                hit: false\n            });\n        }\n    }\n    return pegs;\n};\n\n/**\n * Generate pegs in a circular shape\n * @returns The pegs in a circle\n */\nconst generatePegsCircular = () => {\n    const centerX = 200;\n    const centerY = 300;\n    const radius = 100;\n    const angleIncrement = (2 * Math.PI) / NUMBER_OF_PEGS;\n    let pegs = [];\n\n    for (let i = 0; i < NUMBER_OF_PEGS; i++) {\n        const angle = angleIncrement * i;\n        pegs.push({\n            x: centerX + radius * Math.cos(angle),\n            y: centerY + radius * Math.sin(angle),\n            radius: PEG_RADIUS,\n            hit: false\n        });\n    }\n    return pegs;\n};\n\n/**\n * Generate pegs in a hexagonal formation\n * @returns Pegs generated in a hexagon\n */\nconst generatePegsHexagonal = () => {\n    let pegs = [];\n    const rows = 5;\n    const cols = 5;\n    const spacing = 50;\n    const startX = 100;\n    const startY = 150;\n    const verticalSpacing = spacing * Math.sqrt(3) / 2;\n\n    for (let row = 0; row < rows; row++) {\n        const rowOffset = (row % 2 === 0) ? 0 : spacing / 2;\n\n        for (let col = 0; col < cols; col++) {\n            pegs.push({\n                x: startX + col * spacing + rowOffset, \n                y: startY + row * verticalSpacing, \n                radius: PEG_RADIUS,\n                hit: false\n            });\n        }\n    }\n\n    return pegs;\n};\n\n\n/**\n * Generate the pegs in a triangular shape\n * @returns The pegs in a triangle shape\n */\nconst generatePegsTriangular = () => {\n    // Array for pegs\n    let pegs = [];\n    const numRows = 5;\n    // Start x for first row\n    const xPos = 200;\n    // Start y for first row\n    const yPos = 220;\n    // Peg spacing\n    const pegSpacing = 40;\n\n    for (let row = 0; row < numRows; row++) {\n        // Center the row by adjusting the starting x position based on the row number\n        const startX = xPos - (row * pegSpacing) / 2;\n\n        for (let col = 0; col <= row; col++) {\n            // Calculate the x and y positions for each peg in the current row\n            const x = startX + col * pegSpacing;\n            const y = yPos + row * pegSpacing;\n            pegs.push({\n                x: x,\n                y: y,\n                radius: PEG_RADIUS,\n                hit: false\n            });\n        }\n    }\n    return pegs;\n};\n\n\nexport { \n    generatePegsRandomly, \n    generatePegsGrid, \n    generatePegsCircular, \n    generatePegsHexagonal, \n    generatePegsTriangular \n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
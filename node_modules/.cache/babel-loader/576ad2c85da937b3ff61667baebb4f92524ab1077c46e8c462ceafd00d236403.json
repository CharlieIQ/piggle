{"ast":null,"code":"var _jsxFileName = \"/Users/charliemclaughlin/Desktop/Programming/JavaScript/Piggle/piggle/src/PiggleGame.js\",\n  _s = $RefreshSig$();\nimport { useEffect, useRef, useState } from \"react\";\n\n// This is the main game component, PiggleGame\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function PiggleGame() {\n  _s();\n  // canvasRef is used to access the canvas element\n  const canvasRef = useRef(null);\n\n  // Numerical constant values\n  const BALL_GRAVITY = 0.03;\n\n  // ballRef holds the state of the ball: position, velocity (dx, dy), radius, and launch status\n  const ballRef = useRef({\n    x: 200,\n    y: 50,\n    dx: 0,\n    dy: 0,\n    radius: 10,\n    launched: false\n  });\n\n  // cannonAngle stores the current angle of the cannon\n  const [cannonAngle, setCannonAngle] = useState(0);\n\n  // generatePegs creates a list of pegs with random positions\n  const generatePegs = () =>\n  // Generated 10 pegs\n\n  Array.from({\n    length: 10\n  }, () => ({\n    // Random x position within canvas width\n    x: Math.random() * 380 + 10,\n    y: Math.random() * 300 + 100,\n    // Random y position within the lower part of the canvas\n    radius: 10,\n    // Size of the pegs\n    hit: false // Track if the peg has been hit\n  }));\n\n  // pegs holds the current state of all pegs in the game\n  const pegs = useRef(generatePegs());\n\n  // useEffect runs the game loop and handles rendering\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n    let animationFrameId;\n\n    // drawCannon draws the cannon at the current angle\n    const drawCannon = () => {\n      ctx.save();\n      ctx.translate(200, 50); // Position the cannon at (200, 50)\n      ctx.rotate(cannonAngle); // Rotate the cannon by the current cannonAngle\n      ctx.fillStyle = \"black\"; // Set cannon color\n      ctx.fillRect(-10, -10, 30, 20); // Draw the cannon (a black rectangle)\n      ctx.restore();\n    };\n\n    // drawBall draws the ball at its current position\n    const drawBall = () => {\n      ctx.beginPath(); // Start a new drawing path\n      ctx.arc(ballRef.current.x, ballRef.current.y, ballRef.current.radius, 0, Math.PI * 2); // Draw a circle (ball)\n      ctx.fillStyle = \"purple\"; // Set ball color to red\n      ctx.fill(); // Fill the circle with color\n      ctx.closePath(); // Close the drawing path\n    };\n\n    // drawPegs draws each peg on the canvas, skipping those that have been hit\n    const drawPegs = () => {\n      pegs.current.forEach(peg => {\n        if (!peg.hit) {\n          ctx.beginPath();\n          ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2); // Draw each peg as a circle\n          ctx.fillStyle = \"blue\"; // Set peg color to blue\n          ctx.fill();\n          ctx.closePath();\n        }\n      });\n    };\n\n    // handleCollisions checks if the ball has collided with any pegs\n    const handleCollisions = () => {\n      pegs.current.forEach(peg => {\n        // Skip if the peg has already been hit\n        if (peg.hit) return;\n\n        // Horizontal distance between ball and peg\n        const dx = ballRef.current.x - peg.x;\n        // Vertical distance between ball and peg\n        const dy = ballRef.current.y - peg.y;\n        const distance = Math.sqrt(dx * dx + dy * dy); // Calculate distance between ball and peg\n\n        // If the ball's radius plus the peg's radius is larger than the distance, a collision occurred\n        if (distance < ballRef.current.radius + peg.radius) {\n          const normalX = dx / distance; // Normal vector (x-component)\n          const normalY = dy / distance; // Normal vector (y-component)\n          const dotProduct = ballRef.current.dx * normalX + ballRef.current.dy * normalY; // Dot product of ball's velocity and normal vector\n\n          // Reflect the ball's velocity off the peg by adjusting its velocity (bounce effect)\n          ballRef.current.dx -= 2 * dotProduct * normalX;\n          ballRef.current.dy -= 2 * dotProduct * normalY;\n          // Mark peg as hit\n          peg.hit = true;\n        }\n      });\n    };\n\n    // updateBall updates the position of the ball based on its velocity\n    const updateBall = () => {\n      let ball = ballRef.current;\n      if (ball.launched) {\n        // Gravity effect \n        ball.dy += BALL_GRAVITY;\n        // Update ball's x-position based on horizontal velocity\n        ball.x += ball.dx;\n        // Update ball's y-position based on vertical velocity\n        ball.y += ball.dy;\n\n        // Check for wall collisions and reverse direction if needed\n        if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width || ball.y + ball.radius <= 0) {\n          // Reverse horizontal velocity on wall hit\n          ball.dx *= -1;\n        }\n        if (ball.y + ball.radius > canvas.height) {\n          // Ball hit the ground\n          ball.launched = false; // Stop the ball from moving\n          ball.x = 200; // Reset ball position\n          ball.y = 50;\n          ball.dx = 0; // Reset velocity\n          ball.dy = 0;\n        }\n        handleCollisions(); // Check for peg collisions\n      }\n    };\n\n    // animate is the main game loop that continuously updates the canvas\n    const animate = () => {\n      ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas before drawing the next frame\n      drawCannon(); // Draw the cannon\n      drawPegs(); // Draw the pegs\n      drawBall(); // Draw the ball\n      updateBall(); // Update ball position and handle gravity/collisions\n      animationFrameId = requestAnimationFrame(animate); // Request the next animation frame\n    };\n    animate(); // Start the game loop\n    return () => cancelAnimationFrame(animationFrameId); // Cleanup on component unmount\n  }, [cannonAngle]); // Re-run useEffect when cannonAngle changes\n\n  // launchBall starts the ball's movement when clicked\n  const launchBall = () => {\n    if (!ballRef.current.launched) {\n      // Set ball's initial velocity based on cannon angle\n      ballRef.current.dx = Math.cos(cannonAngle) * 3;\n      ballRef.current.dy = Math.sin(cannonAngle) * 2;\n      ballRef.current.launched = true; // Mark ball as launched\n    }\n  };\n\n  // handleMouseMove updates the cannon angle based on mouse position\n  const handleMouseMove = event => {\n    const canvas = canvasRef.current;\n    // Get the position of the canvas on screen\n    const rect = canvas.getBoundingClientRect();\n    // Calculate mouse X relative to canvas\n    const mouseX = event.clientX - rect.left;\n    // Calculate mouse Y relative to canvas\n    const mouseY = event.clientY - rect.top;\n    // Update the cannon angle based on mouse position\n    setCannonAngle(Math.atan2(mouseY - 50, mouseX - 200));\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      // Attach canvas reference\n      ref: canvasRef,\n      width: 400,\n      height: 500,\n      className: \"border\"\n      // Launch ball on canvas click\n      ,\n      onClick: launchBall\n      // Update cannon angle on mouse movement\n      ,\n      onMouseMove: handleMouseMove\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 171,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 170,\n    columnNumber: 9\n  }, this);\n}\n_s(PiggleGame, \"ANQVY8HOxkQVjCc8yt1wAnelezA=\");\n_c = PiggleGame;\nvar _c;\n$RefreshReg$(_c, \"PiggleGame\");","map":{"version":3,"names":["useEffect","useRef","useState","jsxDEV","_jsxDEV","PiggleGame","_s","canvasRef","BALL_GRAVITY","ballRef","x","y","dx","dy","radius","launched","cannonAngle","setCannonAngle","generatePegs","Array","from","length","Math","random","hit","pegs","canvas","current","ctx","getContext","animationFrameId","drawCannon","save","translate","rotate","fillStyle","fillRect","restore","drawBall","beginPath","arc","PI","fill","closePath","drawPegs","forEach","peg","handleCollisions","distance","sqrt","normalX","normalY","dotProduct","updateBall","ball","width","height","animate","clearRect","requestAnimationFrame","cancelAnimationFrame","launchBall","cos","sin","handleMouseMove","event","rect","getBoundingClientRect","mouseX","clientX","left","mouseY","clientY","top","atan2","children","ref","className","onClick","onMouseMove","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/charliemclaughlin/Desktop/Programming/JavaScript/Piggle/piggle/src/PiggleGame.js"],"sourcesContent":["import { useEffect, useRef, useState } from \"react\";\n\n// This is the main game component, PiggleGame\nexport default function PiggleGame() {\n    // canvasRef is used to access the canvas element\n    const canvasRef = useRef(null);\n\n    // Numerical constant values\n    const BALL_GRAVITY = 0.03;\n\n    // ballRef holds the state of the ball: position, velocity (dx, dy), radius, and launch status\n    const ballRef = useRef({\n        x: 200,\n        y: 50,\n        dx: 0,\n        dy: 0,\n        radius: 10,\n        launched: false\n    });\n\n    // cannonAngle stores the current angle of the cannon\n    const [cannonAngle, setCannonAngle] = useState(0);\n\n    // generatePegs creates a list of pegs with random positions\n    const generatePegs = () => (\n        // Generated 10 pegs\n\n        Array.from({ length: 10 }, () => ({\n            // Random x position within canvas width\n            x: Math.random() * 380 + 10, \n            y: Math.random() * 300 + 100, // Random y position within the lower part of the canvas\n            radius: 10, // Size of the pegs\n            hit: false // Track if the peg has been hit\n        }))\n    );\n\n    // pegs holds the current state of all pegs in the game\n    const pegs = useRef(generatePegs());\n\n    // useEffect runs the game loop and handles rendering\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n        let animationFrameId;\n\n        // drawCannon draws the cannon at the current angle\n        const drawCannon = () => {\n            ctx.save();\n            ctx.translate(200, 50); // Position the cannon at (200, 50)\n            ctx.rotate(cannonAngle); // Rotate the cannon by the current cannonAngle\n            ctx.fillStyle = \"black\"; // Set cannon color\n            ctx.fillRect(-10, -10, 30, 20); // Draw the cannon (a black rectangle)\n            ctx.restore();\n        };\n\n        // drawBall draws the ball at its current position\n        const drawBall = () => {\n            ctx.beginPath(); // Start a new drawing path\n            ctx.arc(ballRef.current.x, ballRef.current.y, ballRef.current.radius, 0, Math.PI * 2); // Draw a circle (ball)\n            ctx.fillStyle = \"purple\"; // Set ball color to red\n            ctx.fill(); // Fill the circle with color\n            ctx.closePath(); // Close the drawing path\n        };\n\n        // drawPegs draws each peg on the canvas, skipping those that have been hit\n        const drawPegs = () => {\n            pegs.current.forEach(peg => {\n                if (!peg.hit) {\n                    ctx.beginPath();\n                    ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2); // Draw each peg as a circle\n                    ctx.fillStyle = \"blue\"; // Set peg color to blue\n                    ctx.fill();\n                    ctx.closePath();\n                }\n            });\n        };\n\n        // handleCollisions checks if the ball has collided with any pegs\n        const handleCollisions = () => {\n            pegs.current.forEach(peg => {\n                // Skip if the peg has already been hit\n                if (peg.hit) return; \n\n                // Horizontal distance between ball and peg\n                const dx = ballRef.current.x - peg.x;\n                // Vertical distance between ball and peg\n                const dy = ballRef.current.y - peg.y; \n                const distance = Math.sqrt(dx * dx + dy * dy); // Calculate distance between ball and peg\n\n                // If the ball's radius plus the peg's radius is larger than the distance, a collision occurred\n                if (distance < ballRef.current.radius + peg.radius) {\n                    const normalX = dx / distance; // Normal vector (x-component)\n                    const normalY = dy / distance; // Normal vector (y-component)\n                    const dotProduct = ballRef.current.dx * normalX + ballRef.current.dy * normalY; // Dot product of ball's velocity and normal vector\n\n                    // Reflect the ball's velocity off the peg by adjusting its velocity (bounce effect)\n                    ballRef.current.dx -= 2 * dotProduct * normalX;\n                    ballRef.current.dy -= 2 * dotProduct * normalY;\n                    // Mark peg as hit\n                    peg.hit = true; \n                }\n            });\n        };\n\n        // updateBall updates the position of the ball based on its velocity\n        const updateBall = () => {\n            let ball = ballRef.current;\n            if (ball.launched) {\n                // Gravity effect \n                ball.dy += BALL_GRAVITY;\n                // Update ball's x-position based on horizontal velocity\n                ball.x += ball.dx;\n                // Update ball's y-position based on vertical velocity\n                ball.y += ball.dy;\n\n                // Check for wall collisions and reverse direction if needed\n                if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width || ball.y + ball.radius <= 0) {\n                    // Reverse horizontal velocity on wall hit\n                    ball.dx *= -1;\n                }\n                if (ball.y + ball.radius > canvas.height) { // Ball hit the ground\n                    ball.launched = false; // Stop the ball from moving\n                    ball.x = 200; // Reset ball position\n                    ball.y = 50;\n                    ball.dx = 0; // Reset velocity\n                    ball.dy = 0;\n                }\n                handleCollisions(); // Check for peg collisions\n            }\n        };\n\n        // animate is the main game loop that continuously updates the canvas\n        const animate = () => {\n            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas before drawing the next frame\n            drawCannon(); // Draw the cannon\n            drawPegs(); // Draw the pegs\n            drawBall(); // Draw the ball\n            updateBall(); // Update ball position and handle gravity/collisions\n            animationFrameId = requestAnimationFrame(animate); // Request the next animation frame\n        };\n\n        animate(); // Start the game loop\n        return () => cancelAnimationFrame(animationFrameId); // Cleanup on component unmount\n    }, [cannonAngle]); // Re-run useEffect when cannonAngle changes\n\n    // launchBall starts the ball's movement when clicked\n    const launchBall = () => {\n        if (!ballRef.current.launched) {\n            // Set ball's initial velocity based on cannon angle\n            ballRef.current.dx = Math.cos(cannonAngle) * 3;\n            ballRef.current.dy = Math.sin(cannonAngle) * 2;\n            ballRef.current.launched = true; // Mark ball as launched\n        }\n    };\n\n    // handleMouseMove updates the cannon angle based on mouse position\n    const handleMouseMove = (event) => {\n        const canvas = canvasRef.current;\n        // Get the position of the canvas on screen\n        const rect = canvas.getBoundingClientRect();\n        // Calculate mouse X relative to canvas\n        const mouseX = event.clientX - rect.left; \n        // Calculate mouse Y relative to canvas\n        const mouseY = event.clientY - rect.top; \n        // Update the cannon angle based on mouse position\n        setCannonAngle(Math.atan2(mouseY - 50, mouseX - 200)); \n    };\n\n    return (\n        <div>\n            <canvas\n                // Attach canvas reference\n                ref={canvasRef} \n                width={400}\n                height={500}\n                className=\"border\"\n                // Launch ball on canvas click\n                onClick={launchBall} \n                // Update cannon angle on mouse movement\n                onMouseMove={handleMouseMove} \n            />\n        </div>\n    );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
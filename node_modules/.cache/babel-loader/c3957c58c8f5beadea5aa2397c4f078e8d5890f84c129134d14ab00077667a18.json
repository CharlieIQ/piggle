{"ast":null,"code":"var _jsxFileName = \"/Users/charliemclaughlin/Desktop/Programming/GitHub/piggle/src/PiggleGame.js\",\n  _s = $RefreshSig$();\n/**\n * Piggle is a game where you hit pegs with balls\n * \n * @author Charlie McLaughlin\n */\nimport { useEffect, useRef, useState } from \"react\";\n// Import cannon sprite\nimport PigCannon from \"./GameImages/PigCannon.png\";\nimport piggleBall from \"./GameImages/piggleBall.png\";\n\n/**\n * This function is the main game runner for the game\n * @returns The canvas that the game runs in\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function PiggleGame() {\n  _s();\n  // Reference to canvas element\n  const canvasRef = useRef(null);\n  /* Canvas size constants */\n  const CANVAS_HEIGHT = 500;\n  const CANVAS_WIDTH = 400;\n\n  /* Constants for game mechanics */\n  const BALL_GRAVITY = 0.025;\n  const MAX_SHOTS = 10;\n  const NUMBER_OF_PEGS = 20;\n  const PEG_RADIUS = 15;\n\n  /* Constants for game sprites */\n  const cannonImage = useRef(new Image());\n  const piggleImage = useRef(new Image());\n\n  // Ball state variables\n  const ballRef = useRef({\n    x: 200,\n    y: 50,\n    dx: 0,\n    dy: 0,\n    radius: 10,\n    launched: false\n  });\n\n  // State for cannon angle\n  const [cannonAngle, setCannonAngle] = useState(0);\n  // State for remaining shots\n  const [shotsLeft, setShotsLeft] = useState(MAX_SHOTS);\n  // Current score variable\n  const [currentScore, setCurrentScore] = useState(0);\n  // State for game win or lose\n  const [gameMessage, setGameMessage] = useState(\"\");\n\n  /**\n   * This method will generate the pegs randomly\n   * @returns The pegs generated in a random\n   */\n  const generatePegsRandomly = () => Array.from({\n    length: NUMBER_OF_PEGS\n  }, () => ({\n    x: Math.random() * 380 + 10,\n    y: Math.random() * 300 + 100,\n    radius: PEG_RADIUS,\n    hit: false\n  }));\n\n  /**\n   * This method will generate the pegs in a square grid\n   * @returns The pegs in a grid\n   */\n  const generatePegsGrid = () => {\n    // Rows and column number\n    const rows = 5;\n    const cols = 5;\n    // Peg spacing\n    const spacing = 50;\n    // Starting position for the top left peg\n    const startX = 100;\n    const startY = 170;\n\n    // Generate the pegs\n    let pegs = [];\n    for (let row = 0; row < rows; row++) {\n      for (let col = 0; col < cols; col++) {\n        pegs.push({\n          x: startX + col * spacing,\n          y: startY + row * spacing,\n          radius: PEG_RADIUS,\n          hit: false\n        });\n      }\n    }\n    return pegs;\n  };\n\n  /**\n   * Generate pegs in a circular shape\n   * @returns The pegs in a circle\n   */\n  const generatePegsCircular = () => {\n    const centerX = 200;\n    const centerY = 300;\n    const radius = 100;\n    const angleIncrement = 2 * Math.PI / NUMBER_OF_PEGS;\n    let pegs = [];\n    for (let i = 0; i < NUMBER_OF_PEGS; i++) {\n      const angle = angleIncrement * i;\n      pegs.push({\n        x: centerX + radius * Math.cos(angle),\n        y: centerY + radius * Math.sin(angle),\n        radius: PEG_RADIUS,\n        hit: false\n      });\n    }\n    return pegs;\n  };\n\n  /**\n   * Generate pegs in a hexagonal formation\n   * @returns Pegs generated in a hexagon\n   */\n  const generatePegsHexagonal = () => {\n    let pegs = [];\n    const rows = 5; // Number of rows\n    const cols = 5; // Number of columns\n    const spacing = 50; // Horizontal spacing between pegs\n    const startX = 100; // Initial X position\n    const startY = 150; // Initial Y position\n    const verticalSpacing = spacing * Math.sqrt(3) / 2; // Correct vertical spacing for hex grid\n\n    for (let row = 0; row < rows; row++) {\n      // Shift odd-numbered rows slightly right (half of the spacing)\n      const rowOffset = row % 2 === 0 ? 0 : spacing / 2;\n      for (let col = 0; col < cols; col++) {\n        pegs.push({\n          x: startX + col * spacing + rowOffset,\n          // Apply offset only to odd rows\n          y: startY + row * verticalSpacing,\n          // Correct hexagonal spacing\n          radius: PEG_RADIUS,\n          hit: false\n        });\n      }\n    }\n    return pegs;\n  };\n\n  /**\n   * Generate the pegs in a triangular shape\n   * @returns The pegs in a triangle shape\n   */\n  const generatePegsTriangular = () => {\n    // Array for pegs\n    let pegs = [];\n    const numRows = 5;\n    // Start x for first row\n    const xPos = 200;\n    // Start y for first row\n    const yPos = 220;\n    // Peg spacing\n    const pegSpacing = 40;\n    for (let row = 0; row < numRows; row++) {\n      // Center the row by adjusting the starting x position based on the row number\n      const startX = xPos - row * pegSpacing / 2;\n      for (let col = 0; col <= row; col++) {\n        // Calculate the x and y positions for each peg in the current row\n        const x = startX + col * pegSpacing;\n        const y = yPos + row * pegSpacing;\n        pegs.push({\n          x: x,\n          y: y,\n          radius: PEG_RADIUS,\n          hit: false\n        });\n      }\n    }\n    return pegs;\n  };\n\n  // Peg generation logic inside useEffect\n  const pegs = useRef([]);\n  useEffect(() => {\n    // Randomize the pegs every time\n    const pegGeneration = Math.floor(Math.random() * 5); // Correct random generation\n\n    let pegGenShape;\n    // Generate the pegs based on the result of the random variable\n    switch (pegGeneration) {\n      case 0:\n        pegGenShape = generatePegsRandomly();\n        break;\n      case 1:\n        pegGenShape = generatePegsCircular();\n        break;\n      case 2:\n        pegGenShape = generatePegsHexagonal();\n        break;\n      case 3:\n        pegGenShape = generatePegsTriangular();\n        break;\n      case 4:\n        pegGenShape = generatePegsGrid();\n        break;\n      default:\n        pegGenShape = generatePegsRandomly();\n    }\n    // Set pegs after generation\n    pegs.current = pegGenShape;\n  }, []);\n\n  // Game loop\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n    let animationFrameId;\n\n    // To load the images for sprites\n    cannonImage.current.src = PigCannon;\n    piggleImage.current.src = piggleBall;\n\n    /**\n     * Method to generate the cannon\n     */\n    const drawCannon = () => {\n      ctx.save();\n      // Move pivot point to the cannon base\n      ctx.translate(200, 50);\n      // Offset the cannon angle by pi/2 to align barrel with mouse position\n      ctx.rotate(cannonAngle - Math.PI / 2);\n      // Cannon default size\n      const cannonWidth = 40;\n      const cannonHeight = 80;\n      // Generate cannon with position and size\n      ctx.drawImage(cannonImage.current, -(cannonWidth / 2), -(cannonHeight / 3), cannonWidth, cannonHeight);\n      ctx.restore();\n    };\n\n    /**\n    * Method to generate the current ball\n    */\n    const drawBall = () => {\n      var ballSize = 2.5;\n      // Draw the pig sprite\n      if (ballRef.current.launched) {\n        ctx.drawImage(\n        // The image reference\n        piggleImage.current,\n        // x position of the ball\n        ballRef.current.x - ballRef.current.radius,\n        // y position of the ball\n        ballRef.current.y - ballRef.current.radius, ballRef.current.radius * ballSize, ballRef.current.radius * ballSize);\n      }\n    };\n\n    /**\n     * Method to generate the pegs\n     */\n    const drawPegs = () => {\n      if (pegs.current.length > 0) {\n        pegs.current.forEach(peg => {\n          if (!peg.hit) {\n            ctx.beginPath();\n            ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);\n            ctx.fillStyle = \"blue\";\n            ctx.fill();\n            ctx.closePath();\n          }\n        });\n      }\n    };\n\n    /**\n     * Logic to handle peg collisions\n     */\n    const handleCollisions = () => {\n      let numPegsHit = 0;\n      // Checks each peg if it was hit\n      pegs.current.forEach(peg => {\n        // Ignore if peg is hit\n        if (peg.hit) return;\n        numPegsHit++;\n        const dx = ballRef.current.x - peg.x;\n        const dy = ballRef.current.y - peg.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        // Calculate if peg was hit\n        if (distance < ballRef.current.radius + peg.radius) {\n          // Get the direction of the collision by dividing with the distance\n          const normalX = dx / distance;\n          const normalY = dy / distance;\n          // Get the ball speed value by taking the dot product\n          const dotProduct = ballRef.current.dx * normalX + ballRef.current.dy * normalY;\n          ballRef.current.dx -= 2 * dotProduct * normalX;\n          ballRef.current.dy -= 2 * dotProduct * normalY;\n          setCurrentScore(currentScore + 100 * numPegsHit);\n          // Mark the peg as hit\n          peg.hit = true;\n        }\n      });\n    };\n\n    /**\n     * Update the ball position\n     */\n    const updateBall = () => {\n      let ball = ballRef.current;\n      // For ball launch logic\n      if (ball.launched) {\n        ball.dy += BALL_GRAVITY;\n        ball.x += ball.dx;\n        ball.y += ball.dy;\n\n        // For ball hitting walls (flip x speed)\n        if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {\n          ball.dx *= -1;\n        }\n\n        // For ball hitting ceiling (flip y speed)\n        if (ball.y + ball.radius < 0) {\n          ball.dy *= -1;\n        }\n\n        // If ball goes out of bounds on the bottom of the screen\n        if (ball.y + ball.radius > canvas.height) {\n          ball.launched = false;\n          ball.x = 200;\n          ball.y = 50;\n          ball.dx = 0;\n          ball.dy = 0;\n          checkGameStatus();\n        }\n        handleCollisions();\n      }\n    };\n\n    /**\n     * Check if game is won\n     */\n    const checkGameStatus = () => {\n      if (pegs.current.every(peg => peg.hit)) {\n        setGameMessage(\"You Win!\");\n      } else if (shotsLeft <= 0) {\n        setGameMessage(\"You Lose!\");\n      }\n    };\n\n    /**\n     * Draw all of the elements on the canvas\n     */\n    const animate = () => {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      drawCannon();\n      drawPegs();\n      drawBall();\n      updateBall();\n      animationFrameId = requestAnimationFrame(animate);\n    };\n    animate();\n    return () => cancelAnimationFrame(animationFrameId);\n  }, [cannonAngle, shotsLeft]);\n  const launchBall = () => {\n    // Ball will not launch is over or if there's no shots left\n    if (!ballRef.current.launched && shotsLeft > 0 && gameMessage === \"\") {\n      ballRef.current.dx = Math.cos(cannonAngle) * 3;\n      ballRef.current.dy = Math.sin(cannonAngle) * 2;\n      ballRef.current.launched = true;\n      // Update shot count\n      setShotsLeft(shotsLeft - 1);\n    }\n  };\n  /**\n   * Method that will move the cannon with the mouse position\n   */\n  const handleMouseMove = event => {\n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const mouseX = event.clientX - rect.left;\n    const mouseY = event.clientY - rect.top;\n    setCannonAngle(Math.atan2(mouseY - 50, mouseX - 200));\n  };\n  const resetgameRandom = () => {\n    // Reset ball state\n    ballRef.current = {\n      x: 200,\n      y: 50,\n      dx: 0,\n      dy: 0,\n      radius: 10,\n      launched: false\n    };\n\n    // Reset pegs\n    const pegGeneration = Math.floor(Math.random() * 5);\n    let pegGenShape;\n    switch (pegGeneration) {\n      case 0:\n        pegGenShape = generatePegsRandomly();\n        break;\n      case 1:\n        pegGenShape = generatePegsCircular();\n        break;\n      case 2:\n        pegGenShape = generatePegsHexagonal();\n        break;\n      case 3:\n        pegGenShape = generatePegsTriangular();\n        break;\n      case 4:\n        pegGenShape = generatePegsGrid();\n        break;\n      default:\n        pegGenShape = generatePegsRandomly();\n    }\n    pegs.current = pegGenShape;\n\n    // Reset game state\n    setShotsLeft(MAX_SHOTS);\n    setGameMessage(\"\");\n  };\n\n  /**\n   * Return the canvas, game message, and the button to start a new game\n   */\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      textAlign: \"center\"\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"p\", {\n      id: \"shotsLeft\",\n      children: [\"Shots Left: \", shotsLeft]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 415,\n      columnNumber: 13\n    }, this), gameMessage && /*#__PURE__*/_jsxDEV(\"h2\", {\n      children: gameMessage\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 416,\n      columnNumber: 29\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      width: CANVAS_WIDTH,\n      height: CANVAS_HEIGHT,\n      className: \"border\",\n      onClick: launchBall,\n      onMouseMove: handleMouseMove\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 417,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      id: \"score\",\n      children: currentScore\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 425,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      id: \"newGameButtonRandom\",\n      onClick: resetgameRandom,\n      style: {\n        marginTop: \"10px\",\n        padding: \"10px\",\n        fontSize: \"16px\"\n      },\n      children: \"Start a random new game!\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 426,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 414,\n    columnNumber: 9\n  }, this);\n}\n_s(PiggleGame, \"IHtdQWC8KcyvPIceIPw+yZjbRFc=\");\n_c = PiggleGame;\nvar _c;\n$RefreshReg$(_c, \"PiggleGame\");","map":{"version":3,"names":["useEffect","useRef","useState","PigCannon","piggleBall","jsxDEV","_jsxDEV","PiggleGame","_s","canvasRef","CANVAS_HEIGHT","CANVAS_WIDTH","BALL_GRAVITY","MAX_SHOTS","NUMBER_OF_PEGS","PEG_RADIUS","cannonImage","Image","piggleImage","ballRef","x","y","dx","dy","radius","launched","cannonAngle","setCannonAngle","shotsLeft","setShotsLeft","currentScore","setCurrentScore","gameMessage","setGameMessage","generatePegsRandomly","Array","from","length","Math","random","hit","generatePegsGrid","rows","cols","spacing","startX","startY","pegs","row","col","push","generatePegsCircular","centerX","centerY","angleIncrement","PI","i","angle","cos","sin","generatePegsHexagonal","verticalSpacing","sqrt","rowOffset","generatePegsTriangular","numRows","xPos","yPos","pegSpacing","pegGeneration","floor","pegGenShape","current","canvas","ctx","getContext","animationFrameId","src","drawCannon","save","translate","rotate","cannonWidth","cannonHeight","drawImage","restore","drawBall","ballSize","drawPegs","forEach","peg","beginPath","arc","fillStyle","fill","closePath","handleCollisions","numPegsHit","distance","normalX","normalY","dotProduct","updateBall","ball","width","height","checkGameStatus","every","animate","clearRect","requestAnimationFrame","cancelAnimationFrame","launchBall","handleMouseMove","event","rect","getBoundingClientRect","mouseX","clientX","left","mouseY","clientY","top","atan2","resetgameRandom","style","textAlign","children","id","fileName","_jsxFileName","lineNumber","columnNumber","ref","className","onClick","onMouseMove","marginTop","padding","fontSize","_c","$RefreshReg$"],"sources":["/Users/charliemclaughlin/Desktop/Programming/GitHub/piggle/src/PiggleGame.js"],"sourcesContent":["/**\n * Piggle is a game where you hit pegs with balls\n * \n * @author Charlie McLaughlin\n */\nimport { useEffect, useRef, useState } from \"react\";\n// Import cannon sprite\nimport PigCannon from \"./GameImages/PigCannon.png\";\nimport piggleBall from \"./GameImages/piggleBall.png\";\n\n/**\n * This function is the main game runner for the game\n * @returns The canvas that the game runs in\n */\nexport default function PiggleGame() {\n    // Reference to canvas element\n    const canvasRef = useRef(null);\n    /* Canvas size constants */\n    const CANVAS_HEIGHT = 500;\n    const CANVAS_WIDTH = 400;\n\n    /* Constants for game mechanics */\n    const BALL_GRAVITY = 0.025;\n    const MAX_SHOTS = 10;\n    const NUMBER_OF_PEGS = 20;\n    const PEG_RADIUS = 15;\n\n    /* Constants for game sprites */\n    const cannonImage = useRef(new Image());\n    const piggleImage = useRef(new Image());\n\n    // Ball state variables\n    const ballRef = useRef({\n        x: 200, y: 50, dx: 0, dy: 0, radius: 10, launched: false\n    });\n\n    // State for cannon angle\n    const [cannonAngle, setCannonAngle] = useState(0);\n    // State for remaining shots\n    const [shotsLeft, setShotsLeft] = useState(MAX_SHOTS);\n    // Current score variable\n    const [currentScore, setCurrentScore] = useState(0);\n    // State for game win or lose\n    const [gameMessage, setGameMessage] = useState(\"\");\n\n\n    /**\n     * This method will generate the pegs randomly\n     * @returns The pegs generated in a random\n     */\n    const generatePegsRandomly = () => (\n        Array.from({ length: NUMBER_OF_PEGS }, () => ({\n            x: (Math.random() * 380) + 10,\n            y: (Math.random() * 300) + 100,\n            radius: PEG_RADIUS,\n            hit: false\n        }))\n    );\n\n    /**\n     * This method will generate the pegs in a square grid\n     * @returns The pegs in a grid\n     */\n    const generatePegsGrid = () => {\n        // Rows and column number\n        const rows = 5;\n        const cols = 5;\n        // Peg spacing\n        const spacing = 50;\n        // Starting position for the top left peg\n        const startX = 100;\n        const startY = 170;\n\n        // Generate the pegs\n        let pegs = [];\n        for (let row = 0; row < rows; row++) {\n            for (let col = 0; col < cols; col++) {\n                pegs.push({\n                    x: startX + col * spacing,\n                    y: startY + row * spacing,\n                    radius: PEG_RADIUS,\n                    hit: false\n                });\n            }\n        }\n        return pegs;\n    };\n\n    /**\n     * Generate pegs in a circular shape\n     * @returns The pegs in a circle\n     */\n    const generatePegsCircular = () => {\n        const centerX = 200;\n        const centerY = 300;\n        const radius = 100;\n        const angleIncrement = (2 * Math.PI) / NUMBER_OF_PEGS;\n        let pegs = [];\n\n        for (let i = 0; i < NUMBER_OF_PEGS; i++) {\n            const angle = angleIncrement * i;\n            pegs.push({\n                x: centerX + radius * Math.cos(angle),\n                y: centerY + radius * Math.sin(angle),\n                radius: PEG_RADIUS,\n                hit: false\n            });\n        }\n        return pegs;\n    };\n\n    /**\n     * Generate pegs in a hexagonal formation\n     * @returns Pegs generated in a hexagon\n     */\n    const generatePegsHexagonal = () => {\n        let pegs = [];\n        const rows = 5;  // Number of rows\n        const cols = 5;  // Number of columns\n        const spacing = 50; // Horizontal spacing between pegs\n        const startX = 100; // Initial X position\n        const startY = 150; // Initial Y position\n        const verticalSpacing = spacing * Math.sqrt(3) / 2; // Correct vertical spacing for hex grid\n    \n        for (let row = 0; row < rows; row++) {\n            // Shift odd-numbered rows slightly right (half of the spacing)\n            const rowOffset = (row % 2 === 0) ? 0 : spacing / 2;\n    \n            for (let col = 0; col < cols; col++) {\n                pegs.push({\n                    x: startX + col * spacing + rowOffset, // Apply offset only to odd rows\n                    y: startY + row * verticalSpacing, // Correct hexagonal spacing\n                    radius: PEG_RADIUS,\n                    hit: false\n                });\n            }\n        }\n    \n        return pegs;\n    };\n    \n    \n\n    /**\n     * Generate the pegs in a triangular shape\n     * @returns The pegs in a triangle shape\n     */\n    const generatePegsTriangular = () => {\n        // Array for pegs\n        let pegs = [];\n        const numRows = 5;\n        // Start x for first row\n        const xPos = 200;\n        // Start y for first row\n        const yPos = 220;\n        // Peg spacing\n        const pegSpacing = 40;\n\n        for (let row = 0; row < numRows; row++) {\n            // Center the row by adjusting the starting x position based on the row number\n            const startX = xPos - (row * pegSpacing) / 2;\n    \n            for (let col = 0; col <= row; col++) {\n                // Calculate the x and y positions for each peg in the current row\n                const x = startX + col * pegSpacing;\n                const y = yPos + row * pegSpacing;\n                pegs.push({\n                    x: x,\n                    y: y,\n                    radius: PEG_RADIUS,\n                    hit: false\n                });\n            }\n        }\n        return pegs;\n    };\n\n    // Peg generation logic inside useEffect\n    const pegs = useRef([]);\n\n    useEffect(() => {\n        // Randomize the pegs every time\n        const pegGeneration = Math.floor(Math.random() * 5);  // Correct random generation\n\n        let pegGenShape;\n        // Generate the pegs based on the result of the random variable\n        switch (pegGeneration) {\n            case 0:\n                pegGenShape = generatePegsRandomly();\n                break;\n            case 1:\n                pegGenShape = generatePegsCircular();\n                break;\n            case 2:\n                pegGenShape = generatePegsHexagonal();\n                break;\n            case 3:\n                pegGenShape = generatePegsTriangular();\n                break;\n            case 4:\n                pegGenShape = generatePegsGrid();\n                break;\n            default:\n                pegGenShape = generatePegsRandomly();\n        }\n        // Set pegs after generation\n        pegs.current = pegGenShape;  \n    }, []);\n\n    // Game loop\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n        let animationFrameId;\n\n        // To load the images for sprites\n        cannonImage.current.src = PigCannon;\n        piggleImage.current.src = piggleBall;\n\n\n        /**\n         * Method to generate the cannon\n         */\n        const drawCannon = () => {\n            ctx.save();\n            // Move pivot point to the cannon base\n            ctx.translate(200, 50);\n            // Offset the cannon angle by pi/2 to align barrel with mouse position\n            ctx.rotate(cannonAngle - (Math.PI / 2));\n            // Cannon default size\n            const cannonWidth = 40;\n            const cannonHeight = 80;\n            // Generate cannon with position and size\n            ctx.drawImage(cannonImage.current, -(cannonWidth / 2), -(cannonHeight/3), cannonWidth, cannonHeight);\n            ctx.restore();\n        };\n\n        /**\n        * Method to generate the current ball\n        */\n        const drawBall = () => {\n            var ballSize = 2.5\n            // Draw the pig sprite\n            if (ballRef.current.launched) {\n                ctx.drawImage(\n                    // The image reference\n                    piggleImage.current,   \n                    // x position of the ball\n                    ballRef.current.x - ballRef.current.radius,\n                    // y position of the ball\n                    ballRef.current.y - ballRef.current.radius, \n                    ballRef.current.radius * ballSize,   \n                    ballRef.current.radius * ballSize\n                );\n            }\n        };\n\n        /**\n         * Method to generate the pegs\n         */\n        const drawPegs = () => {\n            if (pegs.current.length > 0) {\n                pegs.current.forEach(peg => {\n                    if (!peg.hit) {\n                        ctx.beginPath();\n                        ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);\n                        ctx.fillStyle = \"blue\";\n                        ctx.fill();\n                        ctx.closePath();\n                    }\n                });\n            }\n        };\n\n        /**\n         * Logic to handle peg collisions\n         */\n        const handleCollisions = () => {\n            let numPegsHit = 0;\n            // Checks each peg if it was hit\n            pegs.current.forEach(peg => {\n                // Ignore if peg is hit\n                if (peg.hit) return;\n                numPegsHit++;\n                const dx = ballRef.current.x - peg.x;\n                const dy = ballRef.current.y - peg.y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                // Calculate if peg was hit\n                if (distance < ballRef.current.radius + peg.radius) {\n                    // Get the direction of the collision by dividing with the distance\n                    const normalX = dx / distance;\n                    const normalY = dy / distance;\n                    // Get the ball speed value by taking the dot product\n                    const dotProduct = ballRef.current.dx * normalX + ballRef.current.dy * normalY;\n                    ballRef.current.dx -= 2 * dotProduct * normalX;\n                    ballRef.current.dy -= 2 * dotProduct * normalY;\n                    setCurrentScore(currentScore + (100 * numPegsHit));\n                    // Mark the peg as hit\n                    peg.hit = true;\n                }\n            });\n        };\n\n        /**\n         * Update the ball position\n         */\n        const updateBall = () => {\n            let ball = ballRef.current;\n            // For ball launch logic\n            if (ball.launched) {\n                ball.dy += BALL_GRAVITY;\n                ball.x += ball.dx;\n                ball.y += ball.dy;\n                \n                // For ball hitting walls (flip x speed)\n                if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {\n                    ball.dx *= -1;\n                }\n\n                // For ball hitting ceiling (flip y speed)\n                if (ball.y + ball.radius < 0){\n                    ball.dy *= -1;\n                }\n                \n                // If ball goes out of bounds on the bottom of the screen\n                if (ball.y + ball.radius > canvas.height) {\n                    ball.launched = false;\n                    ball.x = 200;\n                    ball.y = 50;\n                    ball.dx = 0;\n                    ball.dy = 0;\n                    checkGameStatus();\n                }\n                handleCollisions();\n            }\n        };\n\n        /**\n         * Check if game is won\n         */\n        const checkGameStatus = () => {\n            if (pegs.current.every(peg => peg.hit)) {\n                setGameMessage(\"You Win!\");\n            } else if (shotsLeft <= 0) {\n                setGameMessage(\"You Lose!\");\n            }\n        };\n\n        /**\n         * Draw all of the elements on the canvas\n         */\n        const animate = () => {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawCannon();\n            drawPegs();\n            drawBall();\n            updateBall();\n            animationFrameId = requestAnimationFrame(animate);\n        };\n\n        animate();\n        return () => cancelAnimationFrame(animationFrameId);\n    }, [cannonAngle, shotsLeft]);\n\n    const launchBall = () => {\n        // Ball will not launch is over or if there's no shots left\n        if (!ballRef.current.launched && shotsLeft > 0 && gameMessage === \"\") {\n            ballRef.current.dx = Math.cos(cannonAngle) * 3;\n            ballRef.current.dy = Math.sin(cannonAngle) * 2;\n            ballRef.current.launched = true;\n            // Update shot count\n            setShotsLeft(shotsLeft - 1);\n        }\n    };\n    /**\n     * Method that will move the cannon with the mouse position\n     */\n    const handleMouseMove = (event) => {\n        const canvas = canvasRef.current;\n        const rect = canvas.getBoundingClientRect();\n        const mouseX = event.clientX - rect.left;\n        const mouseY = event.clientY - rect.top;\n        setCannonAngle(Math.atan2(mouseY - 50, mouseX - 200));\n    };\n\n    const resetgameRandom = () => {\n        // Reset ball state\n        ballRef.current = {\n            x: 200, y: 50, dx: 0, dy: 0, radius: 10, launched: false\n        };\n\n        // Reset pegs\n        const pegGeneration = Math.floor(Math.random() * 5);\n        let pegGenShape;\n        switch (pegGeneration) {\n            case 0: pegGenShape = generatePegsRandomly(); break;\n            case 1: pegGenShape = generatePegsCircular(); break;\n            case 2: pegGenShape = generatePegsHexagonal(); break;\n            case 3: pegGenShape = generatePegsTriangular(); break;\n            case 4: pegGenShape = generatePegsGrid(); break;\n            default: pegGenShape = generatePegsRandomly();\n        }\n        pegs.current = pegGenShape;\n    \n        // Reset game state\n        setShotsLeft(MAX_SHOTS);\n        setGameMessage(\"\");\n    };\n    \n    /**\n     * Return the canvas, game message, and the button to start a new game\n     */\n    return (\n        <div style={{ textAlign: \"center\" }}>\n            <p id=\"shotsLeft\">Shots Left: {shotsLeft}</p>\n            {gameMessage && <h2>{gameMessage}</h2>}\n            <canvas\n                ref={canvasRef}\n                width={CANVAS_WIDTH}\n                height={CANVAS_HEIGHT}\n                className=\"border\"\n                onClick={launchBall}\n                onMouseMove={handleMouseMove}\n            />\n            <p id=\"score\">{currentScore}</p>\n            <button id=\"newGameButtonRandom\" onClick={resetgameRandom} style={{ marginTop: \"10px\", padding: \"10px\", fontSize: \"16px\" }}>\n            Start a random new game!\n            </button>\n        </div>\n    );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
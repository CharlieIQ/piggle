{"ast":null,"code":"/**\n * Piggle is a game where you hit pegs with balls\n * \n * @author Charlie McLaughlin\n */import{useEffect,useRef,useState}from\"react\";// Import cannon sprite\nimport PigCannon from\"./GameImages/PigCannon.png\";import piggleBall from\"./GameImages/piggleBall.png\";/**\n * This function is the main game runner for the game\n * @returns The canvas that the game runs in\n */import{jsxs as _jsxs,jsx as _jsx}from\"react/jsx-runtime\";export default function PiggleGame(){// Reference to canvas element\nconst canvasRef=useRef(null);/* Canvas size constants */const CANVAS_HEIGHT=500;const CANVAS_WIDTH=400;/* Constants for game mechanics */const BALL_GRAVITY=0.025;const MAX_SHOTS=10;const NUMBER_OF_PEGS=20;const PEG_RADIUS=15;/* Constants for game sprites */const cannonImage=useRef(new Image());const piggleImage=useRef(new Image());// Ball state variables\nconst ballRef=useRef({x:200,y:50,dx:0,dy:0,radius:10,launched:false});// State for cannon angle\nconst[cannonAngle,setCannonAngle]=useState(0);// State for remaining shots\nconst[shotsLeft,setShotsLeft]=useState(MAX_SHOTS);const[gameMessage,setGameMessage]=useState(\"\");/**\n     * This method will generate the pegs randomly\n     * @returns The pegs generated in a random\n     */const generatePegsRandomly=()=>Array.from({length:NUMBER_OF_PEGS},()=>({x:Math.random()*380+10,y:Math.random()*300+100,radius:PEG_RADIUS,hit:false}));/**\n     * This method will generate the pegs in a square grid\n     * @returns The pegs in a grid\n     */const generatePegsGrid=()=>{// Rows and column number\nconst rows=5;const cols=5;// Peg spacing\nconst spacing=50;// Starting position for the top left peg\nconst startX=100;const startY=170;// Generate the pegs\nlet pegs=[];for(let row=0;row<rows;row++){for(let col=0;col<cols;col++){pegs.push({x:startX+col*spacing,y:startY+row*spacing,radius:PEG_RADIUS,hit:false});}}return pegs;};/**\n     * Generate pegs in a circular shape\n     * @returns The pegs in a circle\n     */const generatePegsCircular=()=>{const centerX=200;const centerY=300;const radius=100;const angleIncrement=2*Math.PI/NUMBER_OF_PEGS;let pegs=[];for(let i=0;i<NUMBER_OF_PEGS;i++){const angle=angleIncrement*i;pegs.push({x:centerX+radius*Math.cos(angle),y:centerY+radius*Math.sin(angle),radius:PEG_RADIUS,hit:false});}return pegs;};/**\n     * Generate pegs in a hexagonal formation\n     * @returns Pegs generated in a hexagon\n     */const generatePegsHexagonal=()=>{let pegs=[];const rows=5;// Number of rows\nconst cols=5;// Number of columns\nconst spacing=50;// Horizontal spacing between pegs\nconst startX=100;// Initial X position\nconst startY=150;// Initial Y position\nconst verticalSpacing=spacing*Math.sqrt(3)/2;// Correct vertical spacing for hex grid\nfor(let row=0;row<rows;row++){// Shift odd-numbered rows slightly right (half of the spacing)\nconst rowOffset=row%2===0?0:spacing/2;for(let col=0;col<cols;col++){pegs.push({x:startX+col*spacing+rowOffset,// Apply offset only to odd rows\ny:startY+row*verticalSpacing,// Correct hexagonal spacing\nradius:PEG_RADIUS,hit:false});}}return pegs;};/**\n     * Generate the pegs in a triangular shape\n     * @returns The pegs in a triangle shape\n     */const generatePegsTriangular=()=>{// Array for pegs\nlet pegs=[];const numRows=5;// Start x for first row\nconst xPos=200;// Start y for first row\nconst yPos=220;// Peg spacing\nconst pegSpacing=40;for(let row=0;row<numRows;row++){// Center the row by adjusting the starting x position based on the row number\nconst startX=xPos-row*pegSpacing/2;for(let col=0;col<=row;col++){// Calculate the x and y positions for each peg in the current row\nconst x=startX+col*pegSpacing;const y=yPos+row*pegSpacing;pegs.push({x:x,y:y,radius:PEG_RADIUS,hit:false});}}return pegs;};// Peg generation logic inside useEffect\nconst pegs=useRef([]);useEffect(()=>{// Randomize the pegs every time\nconst pegGeneration=Math.floor(Math.random()*5);// Correct random generation\nlet pegGenShape;// Generate the pegs based on the result of the random variable\nswitch(pegGeneration){case 0:pegGenShape=generatePegsRandomly();break;case 1:pegGenShape=generatePegsCircular();break;case 2:pegGenShape=generatePegsHexagonal();break;case 3:pegGenShape=generatePegsTriangular();break;case 4:pegGenShape=generatePegsGrid();break;default:pegGenShape=generatePegsRandomly();}// Set pegs after generation\npegs.current=pegGenShape;},[]);// Game loop\nuseEffect(()=>{const canvas=canvasRef.current;const ctx=canvas.getContext(\"2d\");let animationFrameId;// To load the images for sprites\ncannonImage.current.src=PigCannon;piggleImage.current.src=piggleBall;/**\n         * Method to generate the cannon\n         */const drawCannon=()=>{ctx.save();// Move pivot point to the cannon base\nctx.translate(200,50);// Offset the cannon angle by pi/2 to align barrel with mouse position\nctx.rotate(cannonAngle-Math.PI/2);// Cannon default size\nconst cannonWidth=40;const cannonHeight=80;// Generate cannon with position and size\nctx.drawImage(cannonImage.current,-(cannonWidth/2),-(cannonHeight/3),cannonWidth,cannonHeight);ctx.restore();};/**\n        * Method to generate the current ball\n        */const drawBall=()=>{var ballSize=2.5;// Draw the pig sprite\nif(ballRef.current.launched){ctx.drawImage(// The image reference\npiggleImage.current,// x position of the ball\nballRef.current.x-ballRef.current.radius,// y position of the ball\nballRef.current.y-ballRef.current.radius,ballRef.current.radius*ballSize,ballRef.current.radius*ballSize);}};/**\n         * Method to generate the pegs\n         */const drawPegs=()=>{if(pegs.current.length>0){pegs.current.forEach(peg=>{if(!peg.hit){ctx.beginPath();ctx.arc(peg.x,peg.y,peg.radius,0,Math.PI*2);ctx.fillStyle=\"blue\";ctx.fill();ctx.closePath();}});}};/**\n         * Logic to handle peg collisions\n         */const handleCollisions=()=>{// Checks each peg if it was hit\npegs.current.forEach(peg=>{// Ignore if peg is hit\nif(peg.hit)return;const dx=ballRef.current.x-peg.x;const dy=ballRef.current.y-peg.y;const distance=Math.sqrt(dx*dx+dy*dy);// Calculate if peg was hit\nif(distance<ballRef.current.radius+peg.radius){// Get the direction of the collision by dividing with the distance\nconst normalX=dx/distance;const normalY=dy/distance;// Get the ball speed value by taking the dot product\nconst dotProduct=ballRef.current.dx*normalX+ballRef.current.dy*normalY;ballRef.current.dx-=2*dotProduct*normalX;ballRef.current.dy-=2*dotProduct*normalY;// Mark the peg as hit\npeg.hit=true;}});};/**\n         * Update the ball position\n         */const updateBall=()=>{let ball=ballRef.current;// For ball launch logic\nif(ball.launched){ball.dy+=BALL_GRAVITY;ball.x+=ball.dx;ball.y+=ball.dy;// For ball hitting walls (flip x speed)\nif(ball.x-ball.radius<0||ball.x+ball.radius>canvas.width){ball.dx*=-1;}// For ball hitting ceiling (flip y speed)\nif(ball.y+ball.radius<0){ball.dy*=-1;}// If ball goes out of bounds on the bottom of the screen\nif(ball.y+ball.radius>canvas.height){ball.launched=false;ball.x=200;ball.y=50;ball.dx=0;ball.dy=0;checkGameStatus();}handleCollisions();}};/**\n         * Check if game is won\n         */const checkGameStatus=()=>{if(pegs.current.every(peg=>peg.hit)){setGameMessage(\"You Win!\");}else if(shotsLeft<=0){setGameMessage(\"You Lose!\");}};/**\n         * Draw all of the elements on the canvas\n         */const animate=()=>{ctx.clearRect(0,0,canvas.width,canvas.height);drawCannon();drawPegs();drawBall();updateBall();animationFrameId=requestAnimationFrame(animate);};animate();return()=>cancelAnimationFrame(animationFrameId);},[cannonAngle,shotsLeft]);const launchBall=()=>{// Ball will not launch is over or if there's no shots left\nif(!ballRef.current.launched&&shotsLeft>0&&gameMessage===\"\"){ballRef.current.dx=Math.cos(cannonAngle)*3;ballRef.current.dy=Math.sin(cannonAngle)*2;ballRef.current.launched=true;// Update shot count\nsetShotsLeft(shotsLeft-1);}};/**\n     * Method that will move the cannon with the mouse position\n     */const handleMouseMove=event=>{const canvas=canvasRef.current;const rect=canvas.getBoundingClientRect();const mouseX=event.clientX-rect.left;const mouseY=event.clientY-rect.top;setCannonAngle(Math.atan2(mouseY-50,mouseX-200));};const resetgameRandom=()=>{// Reset ball state\nballRef.current={x:200,y:50,dx:0,dy:0,radius:10,launched:false};// Reset pegs\nconst pegGeneration=Math.floor(Math.random()*5);let pegGenShape;switch(pegGeneration){case 0:pegGenShape=generatePegsRandomly();break;case 1:pegGenShape=generatePegsCircular();break;case 2:pegGenShape=generatePegsHexagonal();break;case 3:pegGenShape=generatePegsTriangular();break;case 4:pegGenShape=generatePegsGrid();break;default:pegGenShape=generatePegsRandomly();}pegs.current=pegGenShape;// Reset game state\nsetShotsLeft(MAX_SHOTS);setGameMessage(\"\");};/**\n     * Return the canvas, game message, and the button to start a new game\n     */return/*#__PURE__*/_jsxs(\"div\",{style:{textAlign:\"center\"},children:[/*#__PURE__*/_jsxs(\"p\",{id:\"shotsLeft\",children:[\"Shots Left: \",shotsLeft]}),gameMessage&&/*#__PURE__*/_jsx(\"h2\",{children:gameMessage}),/*#__PURE__*/_jsx(\"canvas\",{ref:canvasRef,width:CANVAS_WIDTH,height:CANVAS_HEIGHT,className:\"border\",onClick:launchBall,onMouseMove:handleMouseMove}),/*#__PURE__*/_jsx(\"button\",{id:\"newGameButtonRandom\",onClick:resetgameRandom,style:{marginTop:\"10px\",padding:\"10px\",fontSize:\"16px\"},children:\"Start a random new game!\"})]});}","map":{"version":3,"names":["useEffect","useRef","useState","PigCannon","piggleBall","jsxs","_jsxs","jsx","_jsx","PiggleGame","canvasRef","CANVAS_HEIGHT","CANVAS_WIDTH","BALL_GRAVITY","MAX_SHOTS","NUMBER_OF_PEGS","PEG_RADIUS","cannonImage","Image","piggleImage","ballRef","x","y","dx","dy","radius","launched","cannonAngle","setCannonAngle","shotsLeft","setShotsLeft","gameMessage","setGameMessage","generatePegsRandomly","Array","from","length","Math","random","hit","generatePegsGrid","rows","cols","spacing","startX","startY","pegs","row","col","push","generatePegsCircular","centerX","centerY","angleIncrement","PI","i","angle","cos","sin","generatePegsHexagonal","verticalSpacing","sqrt","rowOffset","generatePegsTriangular","numRows","xPos","yPos","pegSpacing","pegGeneration","floor","pegGenShape","current","canvas","ctx","getContext","animationFrameId","src","drawCannon","save","translate","rotate","cannonWidth","cannonHeight","drawImage","restore","drawBall","ballSize","drawPegs","forEach","peg","beginPath","arc","fillStyle","fill","closePath","handleCollisions","distance","normalX","normalY","dotProduct","updateBall","ball","width","height","checkGameStatus","every","animate","clearRect","requestAnimationFrame","cancelAnimationFrame","launchBall","handleMouseMove","event","rect","getBoundingClientRect","mouseX","clientX","left","mouseY","clientY","top","atan2","resetgameRandom","style","textAlign","children","id","ref","className","onClick","onMouseMove","marginTop","padding","fontSize"],"sources":["/Users/charliemclaughlin/Desktop/Programming/GitHub/piggle/src/PiggleGame.js"],"sourcesContent":["/**\n * Piggle is a game where you hit pegs with balls\n * \n * @author Charlie McLaughlin\n */\nimport { useEffect, useRef, useState } from \"react\";\n// Import cannon sprite\nimport PigCannon from \"./GameImages/PigCannon.png\";\nimport piggleBall from \"./GameImages/piggleBall.png\";\n\n/**\n * This function is the main game runner for the game\n * @returns The canvas that the game runs in\n */\nexport default function PiggleGame() {\n    // Reference to canvas element\n    const canvasRef = useRef(null);\n    /* Canvas size constants */\n    const CANVAS_HEIGHT = 500;\n    const CANVAS_WIDTH = 400;\n\n    /* Constants for game mechanics */\n    const BALL_GRAVITY = 0.025;\n    const MAX_SHOTS = 10;\n    const NUMBER_OF_PEGS = 20;\n    const PEG_RADIUS = 15;\n\n    /* Constants for game sprites */\n    const cannonImage = useRef(new Image());\n    const piggleImage = useRef(new Image());\n\n    // Ball state variables\n    const ballRef = useRef({\n        x: 200, y: 50, dx: 0, dy: 0, radius: 10, launched: false\n    });\n\n    // State for cannon angle\n    const [cannonAngle, setCannonAngle] = useState(0);\n    // State for remaining shots\n    const [shotsLeft, setShotsLeft] = useState(MAX_SHOTS);\n    const [gameMessage, setGameMessage] = useState(\"\");\n\n\n    /**\n     * This method will generate the pegs randomly\n     * @returns The pegs generated in a random\n     */\n    const generatePegsRandomly = () => (\n        Array.from({ length: NUMBER_OF_PEGS }, () => ({\n            x: (Math.random() * 380) + 10,\n            y: (Math.random() * 300) + 100,\n            radius: PEG_RADIUS,\n            hit: false\n        }))\n    );\n\n    /**\n     * This method will generate the pegs in a square grid\n     * @returns The pegs in a grid\n     */\n    const generatePegsGrid = () => {\n        // Rows and column number\n        const rows = 5;\n        const cols = 5;\n        // Peg spacing\n        const spacing = 50;\n        // Starting position for the top left peg\n        const startX = 100;\n        const startY = 170;\n\n        // Generate the pegs\n        let pegs = [];\n        for (let row = 0; row < rows; row++) {\n            for (let col = 0; col < cols; col++) {\n                pegs.push({\n                    x: startX + col * spacing,\n                    y: startY + row * spacing,\n                    radius: PEG_RADIUS,\n                    hit: false\n                });\n            }\n        }\n        return pegs;\n    };\n\n    /**\n     * Generate pegs in a circular shape\n     * @returns The pegs in a circle\n     */\n    const generatePegsCircular = () => {\n        const centerX = 200;\n        const centerY = 300;\n        const radius = 100;\n        const angleIncrement = (2 * Math.PI) / NUMBER_OF_PEGS;\n        let pegs = [];\n\n        for (let i = 0; i < NUMBER_OF_PEGS; i++) {\n            const angle = angleIncrement * i;\n            pegs.push({\n                x: centerX + radius * Math.cos(angle),\n                y: centerY + radius * Math.sin(angle),\n                radius: PEG_RADIUS,\n                hit: false\n            });\n        }\n        return pegs;\n    };\n\n    /**\n     * Generate pegs in a hexagonal formation\n     * @returns Pegs generated in a hexagon\n     */\n    const generatePegsHexagonal = () => {\n        let pegs = [];\n        const rows = 5;  // Number of rows\n        const cols = 5;  // Number of columns\n        const spacing = 50; // Horizontal spacing between pegs\n        const startX = 100; // Initial X position\n        const startY = 150; // Initial Y position\n        const verticalSpacing = spacing * Math.sqrt(3) / 2; // Correct vertical spacing for hex grid\n    \n        for (let row = 0; row < rows; row++) {\n            // Shift odd-numbered rows slightly right (half of the spacing)\n            const rowOffset = (row % 2 === 0) ? 0 : spacing / 2;\n    \n            for (let col = 0; col < cols; col++) {\n                pegs.push({\n                    x: startX + col * spacing + rowOffset, // Apply offset only to odd rows\n                    y: startY + row * verticalSpacing, // Correct hexagonal spacing\n                    radius: PEG_RADIUS,\n                    hit: false\n                });\n            }\n        }\n    \n        return pegs;\n    };\n    \n    \n\n    /**\n     * Generate the pegs in a triangular shape\n     * @returns The pegs in a triangle shape\n     */\n    const generatePegsTriangular = () => {\n        // Array for pegs\n        let pegs = [];\n        const numRows = 5;\n        // Start x for first row\n        const xPos = 200;\n        // Start y for first row\n        const yPos = 220;\n        // Peg spacing\n        const pegSpacing = 40;\n\n        for (let row = 0; row < numRows; row++) {\n            // Center the row by adjusting the starting x position based on the row number\n            const startX = xPos - (row * pegSpacing) / 2;\n    \n            for (let col = 0; col <= row; col++) {\n                // Calculate the x and y positions for each peg in the current row\n                const x = startX + col * pegSpacing;\n                const y = yPos + row * pegSpacing;\n                pegs.push({\n                    x: x,\n                    y: y,\n                    radius: PEG_RADIUS,\n                    hit: false\n                });\n            }\n        }\n        return pegs;\n    };\n\n    // Peg generation logic inside useEffect\n    const pegs = useRef([]);\n\n    useEffect(() => {\n        // Randomize the pegs every time\n        const pegGeneration = Math.floor(Math.random() * 5);  // Correct random generation\n\n        let pegGenShape;\n        // Generate the pegs based on the result of the random variable\n        switch (pegGeneration) {\n            case 0:\n                pegGenShape = generatePegsRandomly();\n                break;\n            case 1:\n                pegGenShape = generatePegsCircular();\n                break;\n            case 2:\n                pegGenShape = generatePegsHexagonal();\n                break;\n            case 3:\n                pegGenShape = generatePegsTriangular();\n                break;\n            case 4:\n                pegGenShape = generatePegsGrid();\n                break;\n            default:\n                pegGenShape = generatePegsRandomly();\n        }\n        // Set pegs after generation\n        pegs.current = pegGenShape;  \n    }, []);\n\n    // Game loop\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n        let animationFrameId;\n\n        // To load the images for sprites\n        cannonImage.current.src = PigCannon;\n        piggleImage.current.src = piggleBall;\n\n\n        /**\n         * Method to generate the cannon\n         */\n        const drawCannon = () => {\n            ctx.save();\n            // Move pivot point to the cannon base\n            ctx.translate(200, 50);\n            // Offset the cannon angle by pi/2 to align barrel with mouse position\n            ctx.rotate(cannonAngle - (Math.PI / 2));\n            // Cannon default size\n            const cannonWidth = 40;\n            const cannonHeight = 80;\n            // Generate cannon with position and size\n            ctx.drawImage(cannonImage.current, -(cannonWidth / 2), -(cannonHeight/3), cannonWidth, cannonHeight);\n            ctx.restore();\n        };\n\n        /**\n        * Method to generate the current ball\n        */\n        const drawBall = () => {\n            var ballSize = 2.5\n            // Draw the pig sprite\n            if (ballRef.current.launched) {\n                ctx.drawImage(\n                    // The image reference\n                    piggleImage.current,   \n                    // x position of the ball\n                    ballRef.current.x - ballRef.current.radius,\n                    // y position of the ball\n                    ballRef.current.y - ballRef.current.radius, \n                    ballRef.current.radius * ballSize,   \n                    ballRef.current.radius * ballSize\n                );\n            }\n        };\n\n        /**\n         * Method to generate the pegs\n         */\n        const drawPegs = () => {\n            if (pegs.current.length > 0) {\n                pegs.current.forEach(peg => {\n                    if (!peg.hit) {\n                        ctx.beginPath();\n                        ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);\n                        ctx.fillStyle = \"blue\";\n                        ctx.fill();\n                        ctx.closePath();\n                    }\n                });\n            }\n        };\n\n        /**\n         * Logic to handle peg collisions\n         */\n        const handleCollisions = () => {\n            // Checks each peg if it was hit\n            pegs.current.forEach(peg => {\n                // Ignore if peg is hit\n                if (peg.hit) return;\n                const dx = ballRef.current.x - peg.x;\n                const dy = ballRef.current.y - peg.y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                // Calculate if peg was hit\n                if (distance < ballRef.current.radius + peg.radius) {\n                    // Get the direction of the collision by dividing with the distance\n                    const normalX = dx / distance;\n                    const normalY = dy / distance;\n                    // Get the ball speed value by taking the dot product\n                    const dotProduct = ballRef.current.dx * normalX + ballRef.current.dy * normalY;\n                    ballRef.current.dx -= 2 * dotProduct * normalX;\n                    ballRef.current.dy -= 2 * dotProduct * normalY;\n                    // Mark the peg as hit\n                    peg.hit = true;\n                }\n            });\n        };\n\n        /**\n         * Update the ball position\n         */\n        const updateBall = () => {\n            let ball = ballRef.current;\n            // For ball launch logic\n            if (ball.launched) {\n                ball.dy += BALL_GRAVITY;\n                ball.x += ball.dx;\n                ball.y += ball.dy;\n                \n                // For ball hitting walls (flip x speed)\n                if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {\n                    ball.dx *= -1;\n                }\n\n                // For ball hitting ceiling (flip y speed)\n                if (ball.y + ball.radius < 0){\n                    ball.dy *= -1;\n                }\n                \n                // If ball goes out of bounds on the bottom of the screen\n                if (ball.y + ball.radius > canvas.height) {\n                    ball.launched = false;\n                    ball.x = 200;\n                    ball.y = 50;\n                    ball.dx = 0;\n                    ball.dy = 0;\n                    checkGameStatus();\n                }\n                handleCollisions();\n            }\n        };\n\n        /**\n         * Check if game is won\n         */\n        const checkGameStatus = () => {\n            if (pegs.current.every(peg => peg.hit)) {\n                setGameMessage(\"You Win!\");\n            } else if (shotsLeft <= 0) {\n                setGameMessage(\"You Lose!\");\n            }\n        };\n\n        /**\n         * Draw all of the elements on the canvas\n         */\n        const animate = () => {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawCannon();\n            drawPegs();\n            drawBall();\n            updateBall();\n            animationFrameId = requestAnimationFrame(animate);\n        };\n\n        animate();\n        return () => cancelAnimationFrame(animationFrameId);\n    }, [cannonAngle, shotsLeft]);\n\n    const launchBall = () => {\n        // Ball will not launch is over or if there's no shots left\n        if (!ballRef.current.launched && shotsLeft > 0 && gameMessage === \"\") {\n            ballRef.current.dx = Math.cos(cannonAngle) * 3;\n            ballRef.current.dy = Math.sin(cannonAngle) * 2;\n            ballRef.current.launched = true;\n            // Update shot count\n            setShotsLeft(shotsLeft - 1);\n        }\n    };\n    /**\n     * Method that will move the cannon with the mouse position\n     */\n    const handleMouseMove = (event) => {\n        const canvas = canvasRef.current;\n        const rect = canvas.getBoundingClientRect();\n        const mouseX = event.clientX - rect.left;\n        const mouseY = event.clientY - rect.top;\n        setCannonAngle(Math.atan2(mouseY - 50, mouseX - 200));\n    };\n\n    const resetgameRandom = () => {\n        // Reset ball state\n        ballRef.current = {\n            x: 200, y: 50, dx: 0, dy: 0, radius: 10, launched: false\n        };\n\n        // Reset pegs\n        const pegGeneration = Math.floor(Math.random() * 5);\n        let pegGenShape;\n        switch (pegGeneration) {\n            case 0: pegGenShape = generatePegsRandomly(); break;\n            case 1: pegGenShape = generatePegsCircular(); break;\n            case 2: pegGenShape = generatePegsHexagonal(); break;\n            case 3: pegGenShape = generatePegsTriangular(); break;\n            case 4: pegGenShape = generatePegsGrid(); break;\n            default: pegGenShape = generatePegsRandomly();\n        }\n        pegs.current = pegGenShape;\n    \n        // Reset game state\n        setShotsLeft(MAX_SHOTS);\n        setGameMessage(\"\");\n    };\n    \n    /**\n     * Return the canvas, game message, and the button to start a new game\n     */\n    return (\n        <div style={{ textAlign: \"center\" }}>\n            <p id=\"shotsLeft\">Shots Left: {shotsLeft}</p>\n            {gameMessage && <h2>{gameMessage}</h2>}\n            <canvas\n                ref={canvasRef}\n                width={CANVAS_WIDTH}\n                height={CANVAS_HEIGHT}\n                className=\"border\"\n                onClick={launchBall}\n                onMouseMove={handleMouseMove}\n            />\n            <button id=\"newGameButtonRandom\" onClick={resetgameRandom} style={{ marginTop: \"10px\", padding: \"10px\", fontSize: \"16px\" }}>\n            Start a random new game!\n            </button>\n        </div>\n    );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
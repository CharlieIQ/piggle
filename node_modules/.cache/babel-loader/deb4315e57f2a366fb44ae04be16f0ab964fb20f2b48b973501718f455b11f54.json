{"ast":null,"code":"/**\n * Piggle is a game where you hit pegs with balls\n * \n * @author Charlie McLaughlin\n */import{useEffect,useRef,useState}from\"react\";// Import cannon sprite\nimport PigCannon from\"./GameImages/PigCannon.png\";import piggleBall from\"./GameImages/piggleBall.png\";/**\n * This function is the main game runner for the game\n * @returns The canvas that the game runs in\n */import{jsxs as _jsxs,jsx as _jsx}from\"react/jsx-runtime\";export default function PiggleGame(){// Reference to canvas element\nconst canvasRef=useRef(null);/* Canvas size constants */const CANVAS_HEIGHT=500;const CANVAS_WIDTH=400;/* Constants for game mechanics */const BALL_GRAVITY=0.025;const MAX_SHOTS=10;const NUMBER_OF_PEGS=20;const PEG_RADIUS=15;/* Constants for game sprites */const cannonImage=useRef(new Image());const piggleImage=useRef(new Image());// Ball state variables\nconst ballRef=useRef({x:200,y:50,dx:0,dy:0,radius:10,launched:false});// State for cannon angle\nconst[cannonAngle,setCannonAngle]=useState(0);// State for remaining shots\nconst[shotsLeft,setShotsLeft]=useState(MAX_SHOTS);// Current score variable\n// (PROPOSED SCORE EQUATION) currentScore + (numberOfPegsHitThisShot * 100)\nconst[currentScore,setCurrentScore]=useState(0);const[pegsHitThisShot,setPegsHitThisShot]=useState(0);// State for game win or lose\nconst[gameMessage,setGameMessage]=useState(\"\");// State for game finished (0 for no, 1 for yes)\nconst[isGameDone,setIsGameDone]=useState(0);/**\n     * This method will generate the pegs randomly\n     * @returns The pegs generated in a random\n     */const generatePegsRandomly=()=>Array.from({length:NUMBER_OF_PEGS},()=>({x:Math.random()*380+10,y:Math.random()*300+100,radius:PEG_RADIUS,hit:false}));/**\n     * This method will generate the pegs in a square grid\n     * @returns The pegs in a grid\n     */const generatePegsGrid=()=>{// Rows and column number\nconst rows=5;const cols=5;// Peg spacing\nconst spacing=50;// Starting position for the top left peg\nconst startX=100;const startY=170;// Generate the pegs\nlet pegs=[];for(let row=0;row<rows;row++){for(let col=0;col<cols;col++){pegs.push({x:startX+col*spacing,y:startY+row*spacing,radius:PEG_RADIUS,hit:false});}}return pegs;};/**\n     * Generate pegs in a circular shape\n     * @returns The pegs in a circle\n     */const generatePegsCircular=()=>{const centerX=200;const centerY=300;const radius=100;const angleIncrement=2*Math.PI/NUMBER_OF_PEGS;let pegs=[];for(let i=0;i<NUMBER_OF_PEGS;i++){const angle=angleIncrement*i;pegs.push({x:centerX+radius*Math.cos(angle),y:centerY+radius*Math.sin(angle),radius:PEG_RADIUS,hit:false});}return pegs;};/**\n     * Generate pegs in a hexagonal formation\n     * @returns Pegs generated in a hexagon\n     */const generatePegsHexagonal=()=>{let pegs=[];const rows=5;// Number of rows\nconst cols=5;// Number of columns\nconst spacing=50;// Horizontal spacing between pegs\nconst startX=100;// Initial X position\nconst startY=150;// Initial Y position\nconst verticalSpacing=spacing*Math.sqrt(3)/2;// Correct vertical spacing for hex grid\nfor(let row=0;row<rows;row++){// Shift odd-numbered rows slightly right (half of the spacing)\nconst rowOffset=row%2===0?0:spacing/2;for(let col=0;col<cols;col++){pegs.push({x:startX+col*spacing+rowOffset,// Apply offset only to odd rows\ny:startY+row*verticalSpacing,// Correct hexagonal spacing\nradius:PEG_RADIUS,hit:false});}}return pegs;};/**\n     * Generate the pegs in a triangular shape\n     * @returns The pegs in a triangle shape\n     */const generatePegsTriangular=()=>{// Array for pegs\nlet pegs=[];const numRows=5;// Start x for first row\nconst xPos=200;// Start y for first row\nconst yPos=220;// Peg spacing\nconst pegSpacing=40;for(let row=0;row<numRows;row++){// Center the row by adjusting the starting x position based on the row number\nconst startX=xPos-row*pegSpacing/2;for(let col=0;col<=row;col++){// Calculate the x and y positions for each peg in the current row\nconst x=startX+col*pegSpacing;const y=yPos+row*pegSpacing;pegs.push({x:x,y:y,radius:PEG_RADIUS,hit:false});}}return pegs;};// Peg generation logic inside useEffect\nconst pegs=useRef([]);/**\n         * This will update the score for every peg hit\n         */useEffect(()=>{if(pegsHitThisShot>0){// Correctly update score based on latest pegsHitThisShot\nsetCurrentScore(prevScore=>prevScore+pegsHitThisShot*100);// Reset after score updates\nsetPegsHitThisShot(0);}},[pegsHitThisShot]);useEffect(()=>{// Randomize the pegs every time\nconst pegGeneration=Math.floor(Math.random()*5);// Correct random generation\nlet pegGenShape;// Generate the pegs based on the result of the random variable\nswitch(pegGeneration){case 0:pegGenShape=generatePegsRandomly();break;case 1:pegGenShape=generatePegsCircular();break;case 2:pegGenShape=generatePegsHexagonal();break;case 3:pegGenShape=generatePegsTriangular();break;case 4:pegGenShape=generatePegsGrid();break;default:pegGenShape=generatePegsRandomly();}// Set pegs after generation\npegs.current=pegGenShape;},[]);// Game loop\nuseEffect(()=>{const canvas=canvasRef.current;const ctx=canvas.getContext(\"2d\");let animationFrameId;// To load the images for sprites\ncannonImage.current.src=PigCannon;piggleImage.current.src=piggleBall;/**\n         * Method to generate the cannon\n         */const drawCannon=()=>{ctx.save();// Move pivot point to the cannon base\nctx.translate(200,50);// Offset the cannon angle by pi/2 to align barrel with mouse position\nctx.rotate(cannonAngle-Math.PI/2);// Cannon default size\nconst cannonWidth=40;const cannonHeight=80;// Generate cannon with position and size\nctx.drawImage(cannonImage.current,-(cannonWidth/2),-(cannonHeight/3),cannonWidth,cannonHeight);ctx.restore();};/**\n        * Method to generate the current ball\n        */const drawBall=()=>{var ballSize=2.5;// Draw the pig sprite\nif(ballRef.current.launched){ctx.drawImage(// The image reference\npiggleImage.current,// x position of the ball\nballRef.current.x-ballRef.current.radius,// y position of the ball\nballRef.current.y-ballRef.current.radius,ballRef.current.radius*ballSize,ballRef.current.radius*ballSize);}};/**\n         * Method to generate the pegs\n         */const drawPegs=()=>{if(pegs.current.length>0){pegs.current.forEach(peg=>{if(!peg.hit){ctx.beginPath();ctx.arc(peg.x,peg.y,peg.radius,0,Math.PI*2);ctx.fillStyle=\"blue\";ctx.fill();ctx.closePath();}});}};/**\n         * Logic to handle peg collisions\n         */const handleCollisions=()=>{let hitCount=0;// Checks each peg if it was hit\npegs.current.forEach(peg=>{// Ignore if peg is hit\nif(peg.hit)return;const dx=ballRef.current.x-peg.x;const dy=ballRef.current.y-peg.y;const distance=Math.sqrt(dx*dx+dy*dy);// Calculate if peg was hit\nif(distance<ballRef.current.radius+peg.radius){// Get the direction of the collision by dividing with the distance\nconst normalX=dx/distance;const normalY=dy/distance;// Get the ball speed value by taking the dot product\nconst dotProduct=ballRef.current.dx*normalX+ballRef.current.dy*normalY;ballRef.current.dx-=2*dotProduct*normalX;ballRef.current.dy-=2*dotProduct*normalY;// Mark the peg as hit\npeg.hit=true;hitCount++;}});setPegsHitThisShot(prev=>prev+hitCount);};/**\n         * Update the ball position\n         */const updateBall=()=>{let ball=ballRef.current;// For ball launch logic\nif(ball.launched){ball.dy+=BALL_GRAVITY;ball.x+=ball.dx;ball.y+=ball.dy;// For ball hitting walls (flip x speed)\nif(ball.x-ball.radius<0||ball.x+ball.radius>canvas.width){ball.dx*=-1;}// For ball hitting ceiling (flip y speed)\nif(ball.y+ball.radius<0){ball.dy*=-1;}// If ball goes out of bounds on the bottom of the screen\nif(ball.y+ball.radius>canvas.height){// Reset Ball position\nball.launched=false;ball.x=200;ball.y=50;ball.dx=0;ball.dy=0;checkGameStatus();}// Handle Peg collisons\nhandleCollisions();}};/**\n         * Check if game is won\n         */const checkGameStatus=()=>{if(pegs.current.every(peg=>peg.hit)){// Add 500 points for every shot not used\nsetGameMessage(\"You Win! Score = \"+(currentScore+shotsLeft*500));setIsGameDone(1);}else if(shotsLeft<=0){setGameMessage(\"You Lose!\");}};/**\n         * Draw all of the elements on the canvas\n         */const animate=()=>{ctx.clearRect(0,0,canvas.width,canvas.height);drawCannon();drawPegs();drawBall();updateBall();animationFrameId=requestAnimationFrame(animate);};animate();return()=>cancelAnimationFrame(animationFrameId);},[cannonAngle,shotsLeft]);const launchBall=()=>{// Ball will not launch is over or if there's no shots left\nif(!ballRef.current.launched&&shotsLeft>0&&gameMessage===\"\"){ballRef.current.dx=Math.cos(cannonAngle)*3;ballRef.current.dy=Math.sin(cannonAngle)*2;ballRef.current.launched=true;// Update shot count\nsetShotsLeft(shotsLeft-1);}};/**\n     * Method that will move the cannon with the mouse position\n     */const handleMouseMove=event=>{const canvas=canvasRef.current;const rect=canvas.getBoundingClientRect();const mouseX=event.clientX-rect.left;const mouseY=event.clientY-rect.top;setCannonAngle(Math.atan2(mouseY-50,mouseX-200));};const resetgameRandom=()=>{// Reset ball state\nballRef.current={x:200,y:50,dx:0,dy:0,radius:10,launched:false};// Reset pegs\nconst pegGeneration=Math.floor(Math.random()*5);let pegGenShape;switch(pegGeneration){case 0:pegGenShape=generatePegsRandomly();break;case 1:pegGenShape=generatePegsCircular();break;case 2:pegGenShape=generatePegsHexagonal();break;case 3:pegGenShape=generatePegsTriangular();break;case 4:pegGenShape=generatePegsGrid();break;default:pegGenShape=generatePegsRandomly();}pegs.current=pegGenShape;// Reset game state\nsetShotsLeft(MAX_SHOTS);setGameMessage(\"\");};/**\n     * Return the canvas, game message, and the button to start a new game\n     */return/*#__PURE__*/_jsxs(\"div\",{style:{textAlign:\"center\"},children:[isGameDone==0&&/*#__PURE__*/_jsxs(\"p\",{id:\"shotsLeft\",children:[\"Shots Left: \",shotsLeft]}),gameMessage&&/*#__PURE__*/_jsx(\"h2\",{id:\"gameMessage\",children:gameMessage}),/*#__PURE__*/_jsx(\"canvas\",{ref:canvasRef,width:CANVAS_WIDTH,height:CANVAS_HEIGHT,className:\"border\",onClick:launchBall,onMouseMove:handleMouseMove}),isGameDone==0&&/*#__PURE__*/_jsx(\"p\",{id:\"score\",children:currentScore}),/*#__PURE__*/_jsx(\"button\",{id:\"newGameButtonRandom\",onClick:resetgameRandom,style:{marginTop:\"10px\",padding:\"10px\",fontSize:\"16px\"},children:\"Start a random new game!\"})]});}","map":{"version":3,"names":["useEffect","useRef","useState","PigCannon","piggleBall","jsxs","_jsxs","jsx","_jsx","PiggleGame","canvasRef","CANVAS_HEIGHT","CANVAS_WIDTH","BALL_GRAVITY","MAX_SHOTS","NUMBER_OF_PEGS","PEG_RADIUS","cannonImage","Image","piggleImage","ballRef","x","y","dx","dy","radius","launched","cannonAngle","setCannonAngle","shotsLeft","setShotsLeft","currentScore","setCurrentScore","pegsHitThisShot","setPegsHitThisShot","gameMessage","setGameMessage","isGameDone","setIsGameDone","generatePegsRandomly","Array","from","length","Math","random","hit","generatePegsGrid","rows","cols","spacing","startX","startY","pegs","row","col","push","generatePegsCircular","centerX","centerY","angleIncrement","PI","i","angle","cos","sin","generatePegsHexagonal","verticalSpacing","sqrt","rowOffset","generatePegsTriangular","numRows","xPos","yPos","pegSpacing","prevScore","pegGeneration","floor","pegGenShape","current","canvas","ctx","getContext","animationFrameId","src","drawCannon","save","translate","rotate","cannonWidth","cannonHeight","drawImage","restore","drawBall","ballSize","drawPegs","forEach","peg","beginPath","arc","fillStyle","fill","closePath","handleCollisions","hitCount","distance","normalX","normalY","dotProduct","prev","updateBall","ball","width","height","checkGameStatus","every","animate","clearRect","requestAnimationFrame","cancelAnimationFrame","launchBall","handleMouseMove","event","rect","getBoundingClientRect","mouseX","clientX","left","mouseY","clientY","top","atan2","resetgameRandom","style","textAlign","children","id","ref","className","onClick","onMouseMove","marginTop","padding","fontSize"],"sources":["/Users/charliemclaughlin/Desktop/Programming/GitHub/piggle/src/PiggleGame.js"],"sourcesContent":["/**\n * Piggle is a game where you hit pegs with balls\n * \n * @author Charlie McLaughlin\n */\nimport { useEffect, useRef, useState } from \"react\";\n// Import cannon sprite\nimport PigCannon from \"./GameImages/PigCannon.png\";\nimport piggleBall from \"./GameImages/piggleBall.png\";\n\n/**\n * This function is the main game runner for the game\n * @returns The canvas that the game runs in\n */\nexport default function PiggleGame() {\n    // Reference to canvas element\n    const canvasRef = useRef(null);\n    /* Canvas size constants */\n    const CANVAS_HEIGHT = 500;\n    const CANVAS_WIDTH = 400;\n\n    /* Constants for game mechanics */\n    const BALL_GRAVITY = 0.025;\n    const MAX_SHOTS = 10;\n    const NUMBER_OF_PEGS = 20;\n    const PEG_RADIUS = 15;\n\n    /* Constants for game sprites */\n    const cannonImage = useRef(new Image());\n    const piggleImage = useRef(new Image());\n\n    // Ball state variables\n    const ballRef = useRef({\n        x: 200, y: 50, dx: 0, dy: 0, radius: 10, launched: false\n    });\n\n    // State for cannon angle\n    const [cannonAngle, setCannonAngle] = useState(0);\n    // State for remaining shots\n    const [shotsLeft, setShotsLeft] = useState(MAX_SHOTS);\n    // Current score variable\n    // (PROPOSED SCORE EQUATION) currentScore + (numberOfPegsHitThisShot * 100)\n    const [currentScore, setCurrentScore] = useState(0);\n    const [pegsHitThisShot, setPegsHitThisShot] = useState(0);\n    // State for game win or lose\n    const [gameMessage, setGameMessage] = useState(\"\");\n    // State for game finished (0 for no, 1 for yes)\n    const [isGameDone, setIsGameDone] = useState(0);\n\n    /**\n     * This method will generate the pegs randomly\n     * @returns The pegs generated in a random\n     */\n    const generatePegsRandomly = () => (\n        Array.from({ length: NUMBER_OF_PEGS }, () => ({\n            x: (Math.random() * 380) + 10,\n            y: (Math.random() * 300) + 100,\n            radius: PEG_RADIUS,\n            hit: false\n        }))\n    );\n\n    /**\n     * This method will generate the pegs in a square grid\n     * @returns The pegs in a grid\n     */\n    const generatePegsGrid = () => {\n        // Rows and column number\n        const rows = 5;\n        const cols = 5;\n        // Peg spacing\n        const spacing = 50;\n        // Starting position for the top left peg\n        const startX = 100;\n        const startY = 170;\n\n        // Generate the pegs\n        let pegs = [];\n        for (let row = 0; row < rows; row++) {\n            for (let col = 0; col < cols; col++) {\n                pegs.push({\n                    x: startX + col * spacing,\n                    y: startY + row * spacing,\n                    radius: PEG_RADIUS,\n                    hit: false\n                });\n            }\n        }\n        return pegs;\n    };\n\n    /**\n     * Generate pegs in a circular shape\n     * @returns The pegs in a circle\n     */\n    const generatePegsCircular = () => {\n        const centerX = 200;\n        const centerY = 300;\n        const radius = 100;\n        const angleIncrement = (2 * Math.PI) / NUMBER_OF_PEGS;\n        let pegs = [];\n\n        for (let i = 0; i < NUMBER_OF_PEGS; i++) {\n            const angle = angleIncrement * i;\n            pegs.push({\n                x: centerX + radius * Math.cos(angle),\n                y: centerY + radius * Math.sin(angle),\n                radius: PEG_RADIUS,\n                hit: false\n            });\n        }\n        return pegs;\n    };\n\n    /**\n     * Generate pegs in a hexagonal formation\n     * @returns Pegs generated in a hexagon\n     */\n    const generatePegsHexagonal = () => {\n        let pegs = [];\n        const rows = 5;  // Number of rows\n        const cols = 5;  // Number of columns\n        const spacing = 50; // Horizontal spacing between pegs\n        const startX = 100; // Initial X position\n        const startY = 150; // Initial Y position\n        const verticalSpacing = spacing * Math.sqrt(3) / 2; // Correct vertical spacing for hex grid\n\n        for (let row = 0; row < rows; row++) {\n            // Shift odd-numbered rows slightly right (half of the spacing)\n            const rowOffset = (row % 2 === 0) ? 0 : spacing / 2;\n\n            for (let col = 0; col < cols; col++) {\n                pegs.push({\n                    x: startX + col * spacing + rowOffset, // Apply offset only to odd rows\n                    y: startY + row * verticalSpacing, // Correct hexagonal spacing\n                    radius: PEG_RADIUS,\n                    hit: false\n                });\n            }\n        }\n\n        return pegs;\n    };\n\n\n\n    /**\n     * Generate the pegs in a triangular shape\n     * @returns The pegs in a triangle shape\n     */\n    const generatePegsTriangular = () => {\n        // Array for pegs\n        let pegs = [];\n        const numRows = 5;\n        // Start x for first row\n        const xPos = 200;\n        // Start y for first row\n        const yPos = 220;\n        // Peg spacing\n        const pegSpacing = 40;\n\n        for (let row = 0; row < numRows; row++) {\n            // Center the row by adjusting the starting x position based on the row number\n            const startX = xPos - (row * pegSpacing) / 2;\n\n            for (let col = 0; col <= row; col++) {\n                // Calculate the x and y positions for each peg in the current row\n                const x = startX + col * pegSpacing;\n                const y = yPos + row * pegSpacing;\n                pegs.push({\n                    x: x,\n                    y: y,\n                    radius: PEG_RADIUS,\n                    hit: false\n                });\n            }\n        }\n        return pegs;\n    };\n\n    // Peg generation logic inside useEffect\n    const pegs = useRef([]);\n\n    /**\n         * This will update the score for every peg hit\n         */\n    useEffect(() => {\n        if (pegsHitThisShot > 0) {\n            // Correctly update score based on latest pegsHitThisShot\n            setCurrentScore(prevScore => prevScore + (pegsHitThisShot * 100));\n\n            // Reset after score updates\n            setPegsHitThisShot(0);\n        }\n    }, [pegsHitThisShot]);\n\n\n    useEffect(() => {\n        // Randomize the pegs every time\n        const pegGeneration = Math.floor(Math.random() * 5);  // Correct random generation\n\n        let pegGenShape;\n        // Generate the pegs based on the result of the random variable\n        switch (pegGeneration) {\n            case 0:\n                pegGenShape = generatePegsRandomly();\n                break;\n            case 1:\n                pegGenShape = generatePegsCircular();\n                break;\n            case 2:\n                pegGenShape = generatePegsHexagonal();\n                break;\n            case 3:\n                pegGenShape = generatePegsTriangular();\n                break;\n            case 4:\n                pegGenShape = generatePegsGrid();\n                break;\n            default:\n                pegGenShape = generatePegsRandomly();\n        }\n        // Set pegs after generation\n        pegs.current = pegGenShape;\n    }, []);\n\n    // Game loop\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n        let animationFrameId;\n\n        // To load the images for sprites\n        cannonImage.current.src = PigCannon;\n        piggleImage.current.src = piggleBall;\n\n\n        /**\n         * Method to generate the cannon\n         */\n        const drawCannon = () => {\n            ctx.save();\n            // Move pivot point to the cannon base\n            ctx.translate(200, 50);\n            // Offset the cannon angle by pi/2 to align barrel with mouse position\n            ctx.rotate(cannonAngle - (Math.PI / 2));\n            // Cannon default size\n            const cannonWidth = 40;\n            const cannonHeight = 80;\n            // Generate cannon with position and size\n            ctx.drawImage(cannonImage.current, -(cannonWidth / 2), -(cannonHeight / 3), cannonWidth, cannonHeight);\n            ctx.restore();\n        };\n\n        /**\n        * Method to generate the current ball\n        */\n        const drawBall = () => {\n            var ballSize = 2.5\n            // Draw the pig sprite\n            if (ballRef.current.launched) {\n                ctx.drawImage(\n                    // The image reference\n                    piggleImage.current,\n                    // x position of the ball\n                    ballRef.current.x - ballRef.current.radius,\n                    // y position of the ball\n                    ballRef.current.y - ballRef.current.radius,\n                    ballRef.current.radius * ballSize,\n                    ballRef.current.radius * ballSize\n                );\n            }\n        };\n\n        /**\n         * Method to generate the pegs\n         */\n        const drawPegs = () => {\n            if (pegs.current.length > 0) {\n                pegs.current.forEach(peg => {\n                    if (!peg.hit) {\n                        ctx.beginPath();\n                        ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);\n                        ctx.fillStyle = \"blue\";\n                        ctx.fill();\n                        ctx.closePath();\n                    }\n                });\n            }\n        };\n\n        /**\n         * Logic to handle peg collisions\n         */\n        const handleCollisions = () => {\n            let hitCount = 0;\n            // Checks each peg if it was hit\n            pegs.current.forEach(peg => {\n                // Ignore if peg is hit\n                if (peg.hit) return;\n                const dx = ballRef.current.x - peg.x;\n                const dy = ballRef.current.y - peg.y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                // Calculate if peg was hit\n                if (distance < ballRef.current.radius + peg.radius) {\n                    // Get the direction of the collision by dividing with the distance\n                    const normalX = dx / distance;\n                    const normalY = dy / distance;\n                    // Get the ball speed value by taking the dot product\n                    const dotProduct = ballRef.current.dx * normalX + ballRef.current.dy * normalY;\n                    ballRef.current.dx -= 2 * dotProduct * normalX;\n                    ballRef.current.dy -= 2 * dotProduct * normalY;\n                    // Mark the peg as hit\n                    peg.hit = true;\n                    hitCount++;\n                }\n            });\n\n            setPegsHitThisShot(prev => prev + hitCount);\n        };\n\n        /**\n         * Update the ball position\n         */\n        const updateBall = () => {\n            let ball = ballRef.current;\n            // For ball launch logic\n            if (ball.launched) {\n                ball.dy += BALL_GRAVITY;\n                ball.x += ball.dx;\n                ball.y += ball.dy;\n\n                // For ball hitting walls (flip x speed)\n                if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {\n                    ball.dx *= -1;\n                }\n\n                // For ball hitting ceiling (flip y speed)\n                if (ball.y + ball.radius < 0) {\n                    ball.dy *= -1;\n                }\n\n                // If ball goes out of bounds on the bottom of the screen\n                if (ball.y + ball.radius > canvas.height) {\n                    // Reset Ball position\n                    ball.launched = false;\n                    ball.x = 200;\n                    ball.y = 50;\n                    ball.dx = 0;\n                    ball.dy = 0;\n                    checkGameStatus();\n                }\n                // Handle Peg collisons\n                handleCollisions();\n            }\n        };\n\n        /**\n         * Check if game is won\n         */\n        const checkGameStatus = () => {\n            if (pegs.current.every(peg => peg.hit)) {\n                // Add 500 points for every shot not used\n                setGameMessage(\"You Win! Score = \" + (currentScore + (shotsLeft * 500)));\n                setIsGameDone(1);\n            } else if (shotsLeft <= 0) {\n                setGameMessage(\"You Lose!\");\n            }\n        };\n\n        /**\n         * Draw all of the elements on the canvas\n         */\n        const animate = () => {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawCannon();\n            drawPegs();\n            drawBall();\n            updateBall();\n            animationFrameId = requestAnimationFrame(animate);\n        };\n\n        animate();\n        return () => cancelAnimationFrame(animationFrameId);\n    }, [cannonAngle, shotsLeft]);\n\n    const launchBall = () => {\n        // Ball will not launch is over or if there's no shots left\n        if (!ballRef.current.launched && shotsLeft > 0 && gameMessage === \"\") {\n            ballRef.current.dx = Math.cos(cannonAngle) * 3;\n            ballRef.current.dy = Math.sin(cannonAngle) * 2;\n            ballRef.current.launched = true;\n            // Update shot count\n            setShotsLeft(shotsLeft - 1);\n        }\n    };\n    /**\n     * Method that will move the cannon with the mouse position\n     */\n    const handleMouseMove = (event) => {\n        const canvas = canvasRef.current;\n        const rect = canvas.getBoundingClientRect();\n        const mouseX = event.clientX - rect.left;\n        const mouseY = event.clientY - rect.top;\n        setCannonAngle(Math.atan2(mouseY - 50, mouseX - 200));\n    };\n\n    const resetgameRandom = () => {\n        // Reset ball state\n        ballRef.current = {\n            x: 200, y: 50, dx: 0, dy: 0, radius: 10, launched: false\n        };\n\n        // Reset pegs\n        const pegGeneration = Math.floor(Math.random() * 5);\n        let pegGenShape;\n        switch (pegGeneration) {\n            case 0: pegGenShape = generatePegsRandomly(); break;\n            case 1: pegGenShape = generatePegsCircular(); break;\n            case 2: pegGenShape = generatePegsHexagonal(); break;\n            case 3: pegGenShape = generatePegsTriangular(); break;\n            case 4: pegGenShape = generatePegsGrid(); break;\n            default: pegGenShape = generatePegsRandomly();\n        }\n        pegs.current = pegGenShape;\n\n        // Reset game state\n        setShotsLeft(MAX_SHOTS);\n        setGameMessage(\"\");\n    };\n\n    /**\n     * Return the canvas, game message, and the button to start a new game\n     */\n    return (\n        <div style={{ textAlign: \"center\" }}>\n            {isGameDone == 0 && <p id=\"shotsLeft\">Shots Left: {shotsLeft}</p>}\n            {gameMessage && <h2 id=\"gameMessage\">{gameMessage}</h2>}\n            <canvas\n                ref={canvasRef}\n                width={CANVAS_WIDTH}\n                height={CANVAS_HEIGHT}\n                className=\"border\"\n                onClick={launchBall}\n                onMouseMove={handleMouseMove}\n            />\n            {isGameDone == 0 && <p id=\"score\">{currentScore}</p>}\n            <button id=\"newGameButtonRandom\" onClick={resetgameRandom} style={{ marginTop: \"10px\", padding: \"10px\", fontSize: \"16px\" }}>\n                Start a random new game!\n            </button>\n        </div>\n    );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}